# MiKo_3076: Do not initialize static members with static members below or in other type parts

## Cause

A static member initializer uses another static member that is defined below it or in another partial type part.

## Rule description

If a static member initializer uses another member defined below or in another type part, it might get initialized with the wrong value at runtime.
This happens because the static member initializes before the other referenced member.

This can cause subtle bugs like `TypeInitializerException` or incorrect values.

### Rationale behind

Static member initialization order is determined by the order in which members are declared in the source code.
When a static member depends on another static member that appears later or in a different partial type part, the initialization order becomes unpredictable and can lead to serious runtime problems.

Ensuring proper static initialization order provides several important benefits:

- **Prevents Runtime Initialization Errors**:
  Referencing static members that have not yet been initialized can cause `TypeInitializerException`, which crashes the application.
  This type of error is particularly serious because it occurs during type initialization and can be difficult to recover from.

- **Avoids Incorrect Default Values**:
  When a static member references another static member that has not been initialized yet, it receives the default value instead of the intended value.
  This can cause subtle bugs where the program runs but produces incorrect results.

- **Makes Code Predictable**:
  When static members are initialized in the correct order, the initialization behavior is predictable and reliable.
  Developers can trust that static members have the expected values when accessed.

- **Simplifies Debugging**:
  Initialization order issues can be extremely difficult to debug because they depend on subtle ordering rules that are not obvious from reading the code.
  Following proper ordering eliminates this entire class of bugs.

- **Improves Code Maintainability**:
  When static members are properly ordered, refactoring and reordering code becomes safer.
  There is less risk of accidentally breaking initialization dependencies.

- **Prevents Partial Type Confusion**:
  When working with partial types, initialization order across different files is based on compiler-specific behavior.
  Avoiding cross-file dependencies makes the code more robust and portable.

## How to fix violations

To fix a violation of this rule, reorder the static members so that dependencies are declared before the members that use them.
If members are in different partial type parts, move them to the same part or use a static constructor to control initialization order explicitly.
Alternatively, refactor the initialization logic to remove the dependency between static members.

## How to suppress violations

```csharp
#pragma warning disable MiKo_3076
#pragma warning restore MiKo_3076
```
