# MiKo_3075: Mark internal and private types as static or sealed unless derivation is needed

## Cause

An internal or private type is neither `static` nor `sealed`, and derivation is not needed.

## Rule description

To ease maintenance, internal and private types should be either `static` or `sealed` unless there is a need for derivation.

These types can be modified later if derivation becomes necessary.
Keeping them static or sealed by default ensures clearer and more manageable code, still being adaptable for future changes.

### Rationale behind

Internal and private types that are not explicitly designed for inheritance should be marked as `static` or `sealed` to communicate design intent and prevent unintended usage.
When types are left unsealed without a clear need for derivation, it creates ambiguity about whether inheritance is supported.

Marking types as `static` or `sealed` by default provides several important benefits:

- **Communicates Design Intent**:
  When a type is `sealed`, it clearly signals that the type was not designed for inheritance.
  This helps other developers understand how the type should be used and prevents misuse.

- **Enables Compiler Optimizations**:
  The compiler can apply performance optimizations to `sealed` types, such as devirtualizing method calls.
  This can improve runtime performance without any code changes.

- **Prevents Fragile Base Class Problems**:
  Unsealed classes can be inherited, which creates maintenance obligations.
  Changes to the base class might break derived classes in unexpected ways.
  Sealing prevents these issues.

- **Simplifies Reasoning**:
  When a type is `sealed`, developers know exactly what behavior to expect.
  There is no need to consider how derived classes might override methods or alter behavior.

- **Reduces Testing Burden**:
  Unsealed classes require testing to ensure they work correctly when inherited.
  Sealing types eliminates this testing requirement for types not designed for inheritance.

- **Makes Refactoring Safer**:
  Changes to `sealed` types only affect the type itself and direct callers.
  Changes to unsealed types might affect unknown derived classes, making refactoring riskier.

- **Allows Later Extension**:
  If inheritance becomes necessary later, the type can be unsealed at that time.
  Starting with `sealed` is safer than starting unsealed because removing `sealed` is a non-breaking change, while adding it can break existing code.

## How to fix violations

To fix a violation of this rule, add the `sealed` keyword to the type declaration if the type has instance members.
If the type only contains static members and no instance members, change it to a `static` class instead.
Only leave the type unsealed if there is a clear and documented need for inheritance.

## How to suppress violations

```csharp
#pragma warning disable MiKo_3075
#pragma warning restore MiKo_3075
```
