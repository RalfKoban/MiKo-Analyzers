# MiKo_5016: Use HashSet for lookups in `List.RemoveAll`

## Cause

A `List.RemoveAll()` call uses `Contains()` on a list instead of a `HashSet`.

## Rule description

To improve performance, use `Contains()` on a `HashSet` inside `List.RemoveAll(...)` calls.
`HashSet` lookup is O(1) while list lookup is O(n), which leads to better runtime performance.
Using `.Contains()` on a list requires looping over it repeatedly, slowing things down.

### Rationale behind

When using `List.RemoveAll()` with a predicate that checks if an item exists in another collection, the choice of collection type has a significant impact on performance.
Using `Contains()` on a list inside `RemoveAll()` results in nested loops, creating an O(n*m) time complexity where n is the size of the original list and m is the size of the lookup collection.

Converting the lookup collection to a `HashSet` before calling `RemoveAll()` provides several important benefits:

- **Dramatically Improved Performance**:
  `HashSet` lookups are O(1) on average, compared to O(n) for lists.
  This makes the overall operation O(n) instead of O(n*m), which can result in massive performance improvements when working with large collections.

- **Reduced CPU Usage**:
  With faster lookups, less processing time is needed to complete the operation.
  This leaves more resources available for other tasks and improves application responsiveness.

- **Better Scalability**:
  As data sets grow larger, the performance difference becomes more pronounced.
  Code that works fine with small lists may become unacceptably slow with larger data sets if not using the appropriate collection type.

- **Minimal Code Changes**:
  Converting a list to a `HashSet` is straightforward and requires only a small change to the code.
  The performance benefits far outweigh the minimal effort required.

- **Best Practice Alignment**:
  Using the right data structure for the task demonstrates understanding of algorithmic complexity and performance considerations.
  This leads to more professional and efficient code.

## How to fix violations

To fix a violation of this rule, convert the collection used in the `Contains()` call to a `HashSet` before calling `List.RemoveAll()`.

## How to suppress violations

```csharp
#pragma warning disable MiKo_5016
#pragma warning restore MiKo_5016
```
