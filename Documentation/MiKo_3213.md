# MiKo_3213: Implement parameterless Dispose method using Basic Dispose pattern

## Cause

The parameterless `Dispose()` method does not follow the Basic Dispose pattern implementation.

## Rule description

The public `Dispose()` method should only call `Dispose(bool disposing)` with `disposing` set to `true`.
All other disposal logic should reside in the `Dispose(bool disposing)` method.
This keeps the Dispose pattern consistent and clear.

### Rationale behind

The Basic Dispose pattern separates the public API (`Dispose()`) from the implementation details (`Dispose(bool disposing)`).
This separation allows finalizers and explicit disposal to share the same cleanup logic while handling managed resources differently.

Following the Basic Dispose pattern implementation provides several important benefits:

- **Improved Consistency**:
  The pattern is a well-established .NET convention.
  Following it makes the code familiar to all .NET developers.

- **Better Separation of Concerns**:
  The parameterless `Dispose()` is a simple entry point that delegates to the full implementation.
  All cleanup logic is centralized in one place.

- **Enhanced Maintainability**:
  Having disposal logic in one method makes it easier to maintain.
  Changes only need to be made in the `Dispose(bool disposing)` method.

- **Support for Finalizers**:
  The pattern allows finalizers to call `Dispose(false)` to clean up unmanaged resources.
  This enables proper cleanup even if `Dispose()` is not called.

- **Clearer Intent**:
  The pattern clearly separates explicit disposal from finalization.
  The `disposing` parameter makes the context explicit.

- **Prevented Errors**:
  Following the standard pattern prevents common mistakes in resource cleanup.
  The structure enforces correct disposal semantics.

## How to fix violations

To fix a violation of this rule, modify the parameterless `Dispose()` method to only call `Dispose(true)`.
Move any other disposal logic into the `Dispose(bool disposing)` method.
Add `GC.SuppressFinalize(this)` if the type has a finalizer.

## How to suppress violations

```csharp
#pragma warning disable MiKo_3213
#pragma warning restore MiKo_3213
```
