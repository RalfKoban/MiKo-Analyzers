# MiKo_0006: Simplify complex local functions

## Cause

A local function has a cyclomatic complexity that is too high.

## Rule description

To make maintenance easier, local functions should be kept simple.
When a local function becomes too complex, it often indicates that it has too many decision points and is violating the Keep It Simple, Stupid (KISS) principle.

Complex local functions are harder to understand, test, and maintain, making the codebase more difficult to work with.

### Rationale behind

Cyclomatic complexity measures the number of independent paths through a local function's code.
High complexity indicates that a local function has many decision points.
Complex local functions defeat the purpose of using local functions to simplify code.

The following code constructs each increase the cyclomatic complexity by 1:
- `if`
- `while`
- `for`
- `foreach`
- `case`
- `continue`
- `goto`
- `&&`
- `||`
- `catch`
- `catch when`
- ternary operator `?:`
- `??`
- `?.`

Keeping local functions simple provides several important benefits:

- **Improved Readability**:
  Simple local functions are easier to read and understand at a glance.
  When a local function contains fewer decision points, developers can quickly grasp what it does.
  This makes the containing method more readable and easier to follow.

- **Easier Testing**:
  While local functions cannot be tested directly, simpler local functions make the containing method easier to test.
  Complex local functions with many paths require more test cases at the containing method level.
  When complexity grows too high, it signals that the logic should be extracted to a regular method where it can be tested independently.

- **Reduced Bug Likelihood**:
  Complex local functions with many branching paths create more opportunities for logical errors.
  When conditions are nested deeply or combined in intricate ways, it becomes harder to verify correctness.
  Simpler local functions have fewer places where bugs can hide.

- **Better Maintainability**:
  When changes are needed, simple local functions are safer to modify.
  The limited number of execution paths makes it easier to predict the impact of modifications.
  Complex local functions often lead to unintended side effects when changed.

- **Clearer Purpose**:
  Local functions are meant to extract small pieces of logic to make the containing method clearer.
  When a local function becomes complex, it obscures rather than clarifies the containing method.
  Simple local functions maintain the clarity that is their primary purpose.

- **Better Design Signals**:
  High complexity in a local function indicates that the logic might be better placed in a regular private method.
  This allows the complex logic to be tested independently and potentially reused.
  Keeping local functions simple maintains appropriate boundaries in code organization.

## How to fix violations

To fix a violation of this rule, refactor the local function to reduce its complexity.
You can do this by:

- Breaking down complex conditional logic into simpler pieces
- Extracting conditions into separate local functions with meaningful names
- Using early returns (guard clauses) to simplify nested conditions
- Converting the local function to a regular method if it becomes too complex
- Simplifying boolean expressions

## How to suppress violations

```csharp
#pragma warning disable MiKo_0006
#pragma warning restore MiKo_0006
```
