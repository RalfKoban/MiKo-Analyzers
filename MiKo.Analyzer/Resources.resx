<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="MiKo_0001_Description" xml:space="preserve">
    <value>Methods should be short to ease reading and maintenance (SRP, SLoA).</value>
  </data>
  <data name="MiKo_0001_MessageFormat" xml:space="preserve">
    <value>Too many LoC: {1,4} (max. {2})</value>
  </data>
  <data name="MiKo_0001_Title" xml:space="preserve">
    <value>Method is too long.</value>
  </data>
  <data name="MiKo_0002_Description" xml:space="preserve">
    <value>Methods should be simple to ease maintenance (KISS).
Following code constructs increase the Cyclomatic Complexity (CC) by +1:
    if | while | for | foreach | case | continue | goto | &amp;&amp; | || | catch | catch when | ternary operator ?: | ?? | ?.</value>
  </data>
  <data name="MiKo_0002_MessageFormat" xml:space="preserve">
    <value>Too high CC: {1,4} (max. {2})</value>
  </data>
  <data name="MiKo_0002_Title" xml:space="preserve">
    <value>Method is too complex.</value>
  </data>
  <data name="MiKo_0003_Description" xml:space="preserve">
    <value>Types should be limited in their size to ease reading and maintenance (SRP).</value>
  </data>
  <data name="MiKo_0003_MessageFormat" xml:space="preserve">
    <value>Too many LoC: {1,4} (max. {2})</value>
  </data>
  <data name="MiKo_0003_Title" xml:space="preserve">
    <value>Type is too long.</value>
  </data>
  <data name="MiKo_0004_Description" xml:space="preserve">
    <value>To follow the SRP, methods should have as few parameters as possible.</value>
  </data>
  <data name="MiKo_0004_MessageFormat" xml:space="preserve">
    <value>Too many parameters: {1,4} (max. {2})</value>
  </data>
  <data name="MiKo_0004_Title" xml:space="preserve">
    <value>Methods should not have too many parameters.</value>
  </data>
  <data name="MiKo_1001_Description" xml:space="preserve">
    <value>To ease maintenance, parameters that inherit from 'System.EventArgs' should be named 'e' .</value>
  </data>
  <data name="MiKo_1001_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/event</value>
  </data>
  <data name="MiKo_1001_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1001_Title" xml:space="preserve">
    <value>'System.EventArgs' parameters on methods should be named properly.</value>
  </data>
  <data name="MiKo_1002_Description" xml:space="preserve">
    <value>To follow the .NET Framework Guidelines, parameters of event handlers should be named 'sender' and 'e'.</value>
  </data>
  <data name="MiKo_1002_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/event</value>
  </data>
  <data name="MiKo_1002_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1002_Title" xml:space="preserve">
    <value>Parameter names do not follow .NET Framework Guidelines for event handlers.</value>
  </data>
  <data name="MiKo_1003_Description" xml:space="preserve">
    <value>Event handlers should start with 'On', followed by the name of the event, to indicate that they handle events.</value>
  </data>
  <data name="MiKo_1003_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/csharp/event-pattern</value>
  </data>
  <data name="MiKo_1003_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1003_Title" xml:space="preserve">
    <value>Event handling method name does not follow the .NET Framework Best Practices.</value>
  </data>
  <data name="MiKo_1004_Description" xml:space="preserve">
    <value>'Event' as suffix in event names is noise and should be avoided.</value>
  </data>
  <data name="MiKo_1004_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1004_Title" xml:space="preserve">
    <value>Events should not contain term 'Event' in their names.</value>
  </data>
  <data name="MiKo_1005_Description" xml:space="preserve">
    <value>To ease maintenance, variables that are of type 'System.EventArgs' (or any inheritors) should be named 'e'.</value>
  </data>
  <data name="MiKo_1005_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1005_Title" xml:space="preserve">
    <value>'System.EventArgs' variables should be named properly.</value>
  </data>
  <data name="MiKo_1006_Description" xml:space="preserve">
    <value>Events shall use 'EventHandler&lt;T&gt;' where 'T' is a class inherited from 'System.EventArgs' that is named after the event.
Example: A 'Loaded' event should use an 'EventHandler&lt;LoadedEventArgs&gt;'.</value>
  </data>
  <data name="MiKo_1006_MessageFormat" xml:space="preserve">
    <value>Use 'EventHandler&lt;{1}&gt;' instead</value>
  </data>
  <data name="MiKo_1006_Title" xml:space="preserve">
    <value>Events shall use 'EventHandler&lt;T&gt;' with properly named 'EventArgs' as 'T'.</value>
  </data>
  <data name="MiKo_1010_Description" xml:space="preserve">
    <value>The purpose of methods is to execute code, so it's useless and repetitive to have 'CanExecute' or 'Execute' in their names.</value>
  </data>
  <data name="MiKo_1010_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1010_Title" xml:space="preserve">
    <value>Methods should not contain 'CanExecute' or 'Execute' in their names.</value>
  </data>
  <data name="MiKo_1011_Description" xml:space="preserve">
    <value>The purpose of methods is to execute code, so it's useless and repetitive to have 'Do' in their names.</value>
  </data>
  <data name="MiKo_1011_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1011_Title" xml:space="preserve">
    <value>Methods should not contain 'Do' in their names.</value>
  </data>
  <data name="MiKo_1012_Description" xml:space="preserve">
    <value>The term 'Fire' is a negative term. Employees get fired (or guns), but not events. Events get raised. So use 'Raise' instead.</value>
  </data>
  <data name="MiKo_1012_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1012_Title" xml:space="preserve">
    <value>Methods should not be named 'Fire'.</value>
  </data>
  <data name="MiKo_1013_Description" xml:space="preserve">
    <value>Many times, the term 'Notify' indicates that an event shall be raised. In such case, the prefix 'On' should be used instead.
Example: Instead of 'NotifyPropertyChanged' use 'OnPropertyChanged'.</value>
  </data>
  <data name="MiKo_1013_MessageFormat" xml:space="preserve">
    <value>Do not use term 'Notify'</value>
  </data>
  <data name="MiKo_1013_Title" xml:space="preserve">
    <value>Methods should not be named 'Notify' or 'OnNotify'.</value>
  </data>
  <data name="MiKo_1014_Description" xml:space="preserve">
    <value>The term 'Check' is ambiguous. If validation of parameters is meant, use something like 'Validate' or 'Verify'. If a check for a specific state is meant, use 'Is', 'Can' or 'Has' instead.</value>
  </data>
  <data name="MiKo_1014_MessageFormat" xml:space="preserve">
    <value>Do not use ambiguous term 'Check'</value>
  </data>
  <data name="MiKo_1014_Title" xml:space="preserve">
    <value>Methods should not be named 'Check'.</value>
  </data>
  <data name="MiKo_1015_Description" xml:space="preserve">
    <value>The term 'Init' is a lazy abbreviation and should not be used. 'Initialize' should be used instead.</value>
  </data>
  <data name="MiKo_1015_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1015_Title" xml:space="preserve">
    <value>Methods should not be named 'Init'.</value>
  </data>
  <data name="MiKo_1016_Description" xml:space="preserve">
    <value>The method belongs to a factory and therefore its name should be started with 'Create'.</value>
  </data>
  <data name="MiKo_1016_MessageFormat" xml:space="preserve">
    <value>Start name with 'Create'</value>
  </data>
  <data name="MiKo_1016_Title" xml:space="preserve">
    <value>Factory methods should be named 'Create'.</value>
  </data>
  <data name="MiKo_1017_Description" xml:space="preserve">
    <value>Methods should not be prefixed with 'Get' or 'Set' if followed by 'Is', 'Can' or 'Has'. That 'Get' or 'Set' is just additional noise and should be avoided.</value>
  </data>
  <data name="MiKo_1017_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1017_Title" xml:space="preserve">
    <value>Methods should not be prefixed with 'Get' or 'Set' if followed by 'Is', 'Can' or 'Has'.</value>
  </data>
  <data name="MiKo_1018_Description" xml:space="preserve">
    <value>Methods should not be suffixed with a noun form of a verb if the verb would fit perfectly as method name.</value>
  </data>
  <data name="MiKo_1018_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1018_Title" xml:space="preserve">
    <value>Methods should not be suffixed with noun of a verb.</value>
  </data>
  <data name="MiKo_1019_Description" xml:space="preserve">
    <value>Methods that are named 'Remove' and have no parameters should be named 'Clear' instead as they do not remove parameters.
Methods that are named 'Clear' and have parameters should be named 'Remove' instead as they do not clear the item.</value>
  </data>
  <data name="MiKo_1019_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1019_Title" xml:space="preserve">
    <value>'Clear' and 'Remove' methods should be named based on their number of parameters.</value>
  </data>
  <data name="MiKo_1020_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1020_MessageFormat" xml:space="preserve">
    <value>Type name exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1020_Title" xml:space="preserve">
    <value>Type names should be limited in length.</value>
  </data>
  <data name="MiKo_1021_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1021_MessageFormat" xml:space="preserve">
    <value>Method name exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1021_Title" xml:space="preserve">
    <value>Method names should be limited in length.</value>
  </data>
  <data name="MiKo_1022_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1022_MessageFormat" xml:space="preserve">
    <value>Parameter name exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1022_Title" xml:space="preserve">
    <value>Parameter names should be limited in length.</value>
  </data>
  <data name="MiKo_1023_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1023_MessageFormat" xml:space="preserve">
    <value>Field name exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1023_Title" xml:space="preserve">
    <value>Field names should be limited in length.</value>
  </data>
  <data name="MiKo_1024_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1024_MessageFormat" xml:space="preserve">
    <value>Property name exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1024_Title" xml:space="preserve">
    <value>Property names should be limited in length.</value>
  </data>
  <data name="MiKo_1025_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1025_MessageFormat" xml:space="preserve">
    <value>Event name exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1025_Title" xml:space="preserve">
    <value>Event names should be limited in length.</value>
  </data>
  <data name="MiKo_1026_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1026_MessageFormat" xml:space="preserve">
    <value>Variable name exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1026_Title" xml:space="preserve">
    <value>Variable names should be limited in length.</value>
  </data>
  <data name="MiKo_1030_Description" xml:space="preserve">
    <value>Indicating that a type is a base type by putting 'Abstract' or 'Base' in its name does not make sense. Every interface or class that is not sealed can act as a base class.</value>
  </data>
  <data name="MiKo_1030_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1030_Title" xml:space="preserve">
    <value>Types should not have an 'Abstract' or 'Base' marker to indicate that they are base types.</value>
  </data>
  <data name="MiKo_1031_Description" xml:space="preserve">
    <value>Indicating that a type is an entity by using 'Model' as its suffix does not make sense. Entities should not be suffixed at all. (eg. 'User' instead of 'UserModel')</value>
  </data>
  <data name="MiKo_1031_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1031_Title" xml:space="preserve">
    <value>Entity types should not use a 'Model' suffix.</value>
  </data>
  <data name="MiKo_1032_Description" xml:space="preserve">
    <value>Indicating that a method deals with an entity by using 'Model' in its name does not make sense.</value>
  </data>
  <data name="MiKo_1032_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1032_Title" xml:space="preserve">
    <value>Methods dealing with entities should not use a 'Model' marker.</value>
  </data>
  <data name="MiKo_1033_Description" xml:space="preserve">
    <value>Indicating that a parameter is an entity by using 'Model' as its suffix does not make sense. Entities should not be suffixed at all. (eg. 'user' instead of 'userModel')</value>
  </data>
  <data name="MiKo_1033_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1033_Title" xml:space="preserve">
    <value>Parameters representing entities should not use a 'Model' suffix.</value>
  </data>
  <data name="MiKo_1034_Description" xml:space="preserve">
    <value>Indicating that a field is an entity by using 'Model' as its suffix does not make sense. Entities should not be suffixed at all. (eg. 'user' instead of 'userModel')</value>
  </data>
  <data name="MiKo_1034_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1034_Title" xml:space="preserve">
    <value>Fields representing entities should not use a 'Model' suffix.</value>
  </data>
  <data name="MiKo_1035_Description" xml:space="preserve">
    <value>Indicating that a property deals with an entity by using 'Model' in its name does not make sense.</value>
  </data>
  <data name="MiKo_1035_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1035_Title" xml:space="preserve">
    <value>Properties dealing with entities should not use a 'Model' marker.</value>
  </data>
  <data name="MiKo_1036_Description" xml:space="preserve">
    <value>Indicating that an event deals with an entity by using 'Model' in its name does not make sense.</value>
  </data>
  <data name="MiKo_1036_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1036_Title" xml:space="preserve">
    <value>Events dealing with entities should not use a 'Model' marker.</value>
  </data>
  <data name="MiKo_1037_Description" xml:space="preserve">
    <value>Indicating that a type is an Enum by using 'Enum' as its suffix does not make sense.</value>
  </data>
  <data name="MiKo_1037_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1037_Title" xml:space="preserve">
    <value>Types should not be suffixed with 'Enum'.</value>
  </data>
  <data name="MiKo_1038_Description" xml:space="preserve">
    <value>To ease maintenance, the names of classes that contain extension methods should end with the same suffix.</value>
  </data>
  <data name="MiKo_1038_MessageFormat" xml:space="preserve">
    <value>End name with '{1}'</value>
  </data>
  <data name="MiKo_1038_Title" xml:space="preserve">
    <value>Classes that contain extension methods should end with same suffix.</value>
  </data>
  <data name="MiKo_1039_Description" xml:space="preserve">
    <value>To ease maintenance, the 'this' parameter of extension methods should have a default name.</value>
  </data>
  <data name="MiKo_1039_MessageFormat" xml:space="preserve">
    <value>Name it {1}</value>
  </data>
  <data name="MiKo_1039_Title" xml:space="preserve">
    <value>Extension methods 'this' parameter should have default name.</value>
  </data>
  <data name="MiKo_1040_Description" xml:space="preserve">
    <value>Suffixes on parameter names (such as 'List') are noise and should be avoided.</value>
  </data>
  <data name="MiKo_1040_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1040_Title" xml:space="preserve">
    <value>Parameters should not be suffixed with implementation details.</value>
  </data>
  <data name="MiKo_1041_Description" xml:space="preserve">
    <value>Suffixes on field names (such as 'List') are noise and should be avoided.</value>
  </data>
  <data name="MiKo_1041_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1041_Title" xml:space="preserve">
    <value>Fields should not be suffixed with implementation details.</value>
  </data>
  <data name="MiKo_1042_Description" xml:space="preserve">
    <value>To ease maintenance, and being consistent with the .NET Framework classes, 'CancellationToken' parameters should have a very specific name.</value>
  </data>
  <data name="MiKo_1042_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1042_Title" xml:space="preserve">
    <value>'CancellationToken' parameters should have specific name.</value>
  </data>
  <data name="MiKo_1043_Description" xml:space="preserve">
    <value>To ease maintenance, 'CancellationToken' variables should have a very specific name.</value>
  </data>
  <data name="MiKo_1043_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1043_Title" xml:space="preserve">
    <value>'CancellationToken' variables should have specific name.</value>
  </data>
  <data name="MiKo_1044_Description" xml:space="preserve">
    <value>To ease maintenance, add the suffix 'Command'.</value>
  </data>
  <data name="MiKo_1044_MessageFormat" xml:space="preserve">
    <value>Add '{1}' as suffix</value>
  </data>
  <data name="MiKo_1044_Title" xml:space="preserve">
    <value>Commands should be suffixed with 'Command'.</value>
  </data>
  <data name="MiKo_1045_Description" xml:space="preserve">
    <value>To ease maintenance, remove the suffix 'Command' as the method itself is invoked by a command.</value>
  </data>
  <data name="MiKo_1045_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1045_Title" xml:space="preserve">
    <value>Methods that are invoked by commands should not be suffixed with 'Command'.</value>
  </data>
  <data name="MiKo_1046_Description" xml:space="preserve">
    <value>To ease maintenance, methods that follow the Task-based Asynchronous Pattern (TAP) should be suffixed with 'Async'.</value>
  </data>
  <data name="MiKo_1046_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap</value>
  </data>
  <data name="MiKo_1046_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1046_Title" xml:space="preserve">
    <value>Asynchronous methods should follow the Task-based Asynchronous Pattern (TAP).</value>
  </data>
  <data name="MiKo_1047_Description" xml:space="preserve">
    <value>To ease maintenance, methods that do not follow the Task-based Asynchronous Pattern (TAP) should not be suffixed with 'Async' as that would indicate that they would follow the pattern.</value>
  </data>
  <data name="MiKo_1047_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap</value>
  </data>
  <data name="MiKo_1047_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1047_Title" xml:space="preserve">
    <value>Methods not following the Task-based Asynchronous Pattern (TAP) should not lie about being asynchronous.</value>
  </data>
  <data name="MiKo_1048_Description" xml:space="preserve">
    <value>Classes that are value converters should end with a specific suffix.</value>
  </data>
  <data name="MiKo_1048_MessageFormat" xml:space="preserve">
    <value>End name with '{1}'</value>
  </data>
  <data name="MiKo_1048_Title" xml:space="preserve">
    <value>To ease maintenance, the names of classes that are value converters should end with the same suffix.</value>
  </data>
  <data name="MiKo_1049_Description" xml:space="preserve">
    <value>Requirement terms such as 'Must', 'Need', 'Shall', 'Should', 'Will' or 'Would' within a name are not explicit enough. Instead, use a positive verb or an adjective like 'Is', 'Has', 'Can', etc.</value>
  </data>
  <data name="MiKo_1049_MessageFormat" xml:space="preserve">
    <value>Do not use '{1}' in name</value>
  </data>
  <data name="MiKo_1049_Title" xml:space="preserve">
    <value>Do not use requirement terms such as 'Shall', 'Should', 'Must' or 'Need' for names.</value>
  </data>
  <data name="MiKo_1050_Description" xml:space="preserve">
    <value>Variables for return values should describe what data they contain and not what they technical are.
So they should have better names than e.g. 'ret', 'retVal' or 'returnValue'.</value>
  </data>
  <data name="MiKo_1050_MessageFormat" xml:space="preserve">
    <value>Use a more descriptive name than '{1}'</value>
  </data>
  <data name="MiKo_1050_Title" xml:space="preserve">
    <value>Return values should have descriptive names.</value>
  </data>
  <data name="MiKo_1051_Description" xml:space="preserve">
    <value>Suffixing delegate parameters with their type is repetitive and provides no value. A more meaningful name (such as 'callback', 'filter' or 'map') provides much more context.</value>
  </data>
  <data name="MiKo_1051_MessageFormat" xml:space="preserve">
    <value>Use a better matching name instead</value>
  </data>
  <data name="MiKo_1051_Title" xml:space="preserve">
    <value>Do not suffix parameters with delegate types.</value>
  </data>
  <data name="MiKo_1052_Description" xml:space="preserve">
    <value>Suffixing delegate variables with their type is repetitive and provides no value. A more meaningful name (such as 'callback', 'filter' or 'map') provides much more context.</value>
  </data>
  <data name="MiKo_1052_MessageFormat" xml:space="preserve">
    <value>Use a better matching name instead</value>
  </data>
  <data name="MiKo_1052_Title" xml:space="preserve">
    <value>Do not suffix variables with delegate types.</value>
  </data>
  <data name="MiKo_1053_Description" xml:space="preserve">
    <value>Suffixing delegate fields with their type is repetitive and provides no value. A more meaningful name (such as 'callback', 'filter' or 'map') provides much more context.</value>
  </data>
  <data name="MiKo_1053_MessageFormat" xml:space="preserve">
    <value>Use a better matching name instead</value>
  </data>
  <data name="MiKo_1053_Title" xml:space="preserve">
    <value>Do not suffix fields with delegate types.</value>
  </data>
  <data name="MiKo_1054_Description" xml:space="preserve">
    <value>Terms such as 'helper' or 'utility' are too generic and meaningless.
Types that are named so do not follow the Single Responsibility Principle (SRP); instead they have a scope that is much too broad.</value>
  </data>
  <data name="MiKo_1054_MessageFormat" xml:space="preserve">
    <value>Remove '{1}' from name</value>
  </data>
  <data name="MiKo_1054_Title" xml:space="preserve">
    <value>Do not name types 'Helper' or 'Utility'.</value>
  </data>
  <data name="MiKo_1055_Description" xml:space="preserve">
    <value>To indicate that fields are the containers for specific dependency properties, those fields should be suffixed with 'Property' (similar as in the .NET Framework).</value>
  </data>
  <data name="MiKo_1055_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/how-to-implement-a-dependency-property</value>
  </data>
  <data name="MiKo_1055_MessageFormat" xml:space="preserve">
    <value>Name it '{1}' instead</value>
  </data>
  <data name="MiKo_1055_Title" xml:space="preserve">
    <value>Dependency properties should be suffixed with 'Property' (as in the .NET Framework).</value>
  </data>
  <data name="MiKo_1056_Description" xml:space="preserve">
    <value>To indicate that fields are the containers for specific dependency properties, those fields should be prefixed with the name of the property (similar as in the .NET Framework).</value>
  </data>
  <data name="MiKo_1056_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/how-to-implement-a-dependency-property</value>
  </data>
  <data name="MiKo_1056_MessageFormat" xml:space="preserve">
    <value>Name it {1} instead</value>
  </data>
  <data name="MiKo_1056_Title" xml:space="preserve">
    <value>Dependency properties should be prefixed with property names (as in the .NET Framework).</value>
  </data>
  <data name="MiKo_1057_Description" xml:space="preserve">
    <value>To indicate that fields are the keys for specific dependency properties, those fields should be suffixed with 'Key' (similar as in the .NET Framework).</value>
  </data>
  <data name="MiKo_1057_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/api/system.windows.dependencypropertykey</value>
  </data>
  <data name="MiKo_1057_MessageFormat" xml:space="preserve">
    <value>Name it '{1}' instead</value>
  </data>
  <data name="MiKo_1057_Title" xml:space="preserve">
    <value>Dependency property keys should be suffixed with 'Key' (as in the .NET Framework).</value>
  </data>
  <data name="MiKo_1058_Description" xml:space="preserve">
    <value>To indicate that fields are the keys for specific dependency properties, those fields should be prefixed with the name of the property (similar as in the .NET Framework).</value>
  </data>
  <data name="MiKo_1058_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/api/system.windows.dependencypropertykey</value>
  </data>
  <data name="MiKo_1058_MessageFormat" xml:space="preserve">
    <value>Name it {1} instead</value>
  </data>
  <data name="MiKo_1058_Title" xml:space="preserve">
    <value>Dependency property keys should be prefixed with property names (as in the .NET Framework).</value>
  </data>
  <data name="MiKo_1059_Description" xml:space="preserve">
    <value>Terms such as 'Impl' or 'Implementation' are meaningless and provide no benefit.
Types that are named so should be better named directly after the interface they implement, but without any 'Impl' marker.</value>
  </data>
  <data name="MiKo_1059_MessageFormat" xml:space="preserve">
    <value>Remove '{1}' from name</value>
  </data>
  <data name="MiKo_1059_Title" xml:space="preserve">
    <value>Do not name types 'Impl' or 'Implementation'.</value>
  </data>
  <data name="MiKo_1060_Description" xml:space="preserve">
    <value>Suffixing methods with number makes it hard for the users of the methods to use them as it is unclear which one is the correct or whether they have to be used in conjunction. So instead of using a number suffix methods should have a proper descriptive name.</value>
  </data>
  <data name="MiKo_1060_MessageFormat" xml:space="preserve">
    <value>Do not use a number as suffix</value>
  </data>
  <data name="MiKo_1060_Title" xml:space="preserve">
    <value>Methods should not be suffixed with a number.</value>
  </data>
  <data name="MiKo_1061_Description" xml:space="preserve">
    <value>If a 'Try' method has an [out] parameter, that [out] parameter shall be named 'result' because it is the actual result of the method.
The method's return value only exists to indicate a success or failure of the operation.</value>
  </data>
  <data name="MiKo_1061_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1061_Title" xml:space="preserve">
    <value>The name of 'Try' method's [out] parameter should be 'result'.</value>
  </data>
  <data name="MiKo_1062_Description" xml:space="preserve">
    <value>Detection methods such as 'Is', 'Has' or 'Contains' should consist only of a few words, such as 'IsOnline' or 'ContainsKey'.
If they consist of more than those few words, these methods (or properties) are probably placed at the wrong place and violate the SRP.</value>
  </data>
  <data name="MiKo_1062_MessageFormat" xml:space="preserve">
    <value>Avoid name with more than {1} words</value>
  </data>
  <data name="MiKo_1062_Title" xml:space="preserve">
    <value>'Is/Has/Contains' methods or properties shall consist of only a few words.</value>
  </data>
  <data name="MiKo_1101_Description" xml:space="preserve">
    <value>A class that is marked as a unit test class should indicate that by the suffix 'Tests' as it normally contains multiple tests.</value>
  </data>
  <data name="MiKo_1101_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1101_Title" xml:space="preserve">
    <value>Test classes should end with 'Tests'.</value>
  </data>
  <data name="MiKo_1102_Description" xml:space="preserve">
    <value>A method that is marked as a unit test should not additionally indicate that it is a unit test by having 'Test' in its name.</value>
  </data>
  <data name="MiKo_1102_MessageFormat" xml:space="preserve">
    <value>Remove '{1}' from name</value>
  </data>
  <data name="MiKo_1102_Title" xml:space="preserve">
    <value>Test methods should not contain 'Test'.</value>
  </data>
  <data name="MiKo_1103_Description" xml:space="preserve">
    <value>A method that is marked as unit test initialization method should be named 'PrepareTest'.</value>
  </data>
  <data name="MiKo_1103_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1103_Title" xml:space="preserve">
    <value>Test initialization methods should be named 'PrepareTest'.</value>
  </data>
  <data name="MiKo_1104_Description" xml:space="preserve">
    <value>A method that is marked as unit test cleanup method should be named 'CleanupTest'.</value>
  </data>
  <data name="MiKo_1104_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1104_Title" xml:space="preserve">
    <value>Test cleanup methods should be named 'CleanupTest'.</value>
  </data>
  <data name="MiKo_1105_Description" xml:space="preserve">
    <value>For maintenance reasons, test methods whose names are written in Pascal-casing are hard to read.
To ease reading, use underscores between the different words instead.</value>
  </data>
  <data name="MiKo_1105_MessageFormat" xml:space="preserve">
    <value>Use underscores instead of Pascal-casing</value>
  </data>
  <data name="MiKo_1105_Title" xml:space="preserve">
    <value>Test methods should not be in Pascal-casing.</value>
  </data>
  <data name="MiKo_1106_Description" xml:space="preserve">
    <value>For maintenance reasons, variables, parameters, properties and fields should be named about what they represent and not what they technically are.
Hence naming them e.g. 'Mock' or 'Stub' does not provide any additional value and is just some cluttering noise. In addition, those names put the developer's attention and focus on the wrong thing.</value>
  </data>
  <data name="MiKo_1106_MessageFormat" xml:space="preserve">
    <value>Do not name it 'Mock' or 'Stub'</value>
  </data>
  <data name="MiKo_1106_Title" xml:space="preserve">
    <value>Do not name variables, parameters, fields and properties 'Mock' or 'Stub'.</value>
  </data>
  <data name="MiKo_1200_Description" xml:space="preserve">
    <value>To ease maintenance, exceptions in catch blocks should be named consistently.</value>
  </data>
  <data name="MiKo_1200_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1200_Title" xml:space="preserve">
    <value>Name exceptions in catch blocks consistently.</value>
  </data>
  <data name="MiKo_1201_Description" xml:space="preserve">
    <value>To ease maintenance, exceptions as parameters should be named consistently.</value>
  </data>
  <data name="MiKo_1201_MessageFormat" xml:space="preserve">
    <value>Name it '{1}' or '{2}'</value>
  </data>
  <data name="MiKo_1201_Title" xml:space="preserve">
    <value>Name exceptions as parameters consistently.</value>
  </data>
  <data name="MiKo_1300_Description" xml:space="preserve">
    <value>To ease maintenance and avoid visual noise, unimportant identifiers in lambdas should be consistently named '_'.</value>
  </data>
  <data name="MiKo_1300_MessageFormat" xml:space="preserve">
    <value>Use '_' instead</value>
  </data>
  <data name="MiKo_1300_Title" xml:space="preserve">
    <value>Unimportant identifiers in lambda statements should be named '_'.</value>
  </data>
  <data name="MiKo_1400_Description" xml:space="preserve">
    <value>Namespaces group functionalities, so their names should be in plural.</value>
  </data>
  <data name="MiKo_1400_MessageFormat" xml:space="preserve">
    <value>Use plural for namespace, such as '{1}'</value>
  </data>
  <data name="MiKo_1400_Title" xml:space="preserve">
    <value>Namespace names should be in plural.</value>
  </data>
  <data name="MiKo_1401_Description" xml:space="preserve">
    <value>Namespaces should not contain any language specific (technical) name, such as  'Interfaces', 'Exceptions' or 'Enums'.</value>
  </data>
  <data name="MiKo_1401_MessageFormat" xml:space="preserve">
    <value>Do not use technical name '{1}' in namespace</value>
  </data>
  <data name="MiKo_1401_Title" xml:space="preserve">
    <value>Namespaces should not contain technical language names.</value>
  </data>
  <data name="MiKo_1402_Description" xml:space="preserve">
    <value>Namespaces should not be named after WPF specific design patterns, such as 'Commands', 'Models', 'ViewModels' or 'Views'.
Models are Entities. Commands, ViewModels and Views belong together and are UI specific parts.</value>
  </data>
  <data name="MiKo_1402_MessageFormat" xml:space="preserve">
    <value>Do not use WPF design pattern name '{1}' in namespace</value>
  </data>
  <data name="MiKo_1402_Title" xml:space="preserve">
    <value>Namespaces should not be named after WPF specific design patterns.</value>
  </data>
  <data name="MiKo_1403_Description" xml:space="preserve">
    <value>To avoid redundancy and confused developers, namespaces should ot be named after any parent namespace. Instead, it should be made more clear into which namespace a type belongs by choosing a proper name.</value>
  </data>
  <data name="MiKo_1403_MessageFormat" xml:space="preserve">
    <value>Use another name for the namespace</value>
  </data>
  <data name="MiKo_1403_Title" xml:space="preserve">
    <value>Namespaces should be named after any of their parent namespaces.</value>
  </data>
  <data name="MiKo_1404_Description" xml:space="preserve">
    <value>Namespaces should not contain any unspecific name, such as  'Miscellaneous' or 'Utilities'.</value>
  </data>
  <data name="MiKo_1404_MessageFormat" xml:space="preserve">
    <value>Do not use '{1}' in namespace</value>
  </data>
  <data name="MiKo_1404_Title" xml:space="preserve">
    <value>Namespaces should not contain unspecific names.</value>
  </data>
  <data name="MiKo_1405_Description" xml:space="preserve">
    <value>Namespaces should be named after features, not deployment details.
Most times, a Lib suffix only signals that the assembly is a DLL (dynamic link library). This information is not needed at all.
It does not matter if it is a library or an executable, what matters is the functionality it contains/provides.</value>
  </data>
  <data name="MiKo_1405_MessageFormat" xml:space="preserve">
    <value>Remove '{1}' from namespace</value>
  </data>
  <data name="MiKo_1405_Title" xml:space="preserve">
    <value>Namespaces should not contain 'Lib'.</value>
  </data>
  <data name="MiKo_1406_Description" xml:space="preserve">
    <value>To ease their finding, value converters should be placed and grouped in a specific namespace called 'Converters'.</value>
  </data>
  <data name="MiKo_1406_MessageFormat" xml:space="preserve">
    <value>Place in 'Converters' namespace</value>
  </data>
  <data name="MiKo_1406_Title" xml:space="preserve">
    <value>Value converters should be placed in 'Converters' namespace.</value>
  </data>
  <data name="MiKo_1407_Description" xml:space="preserve">
    <value>A test should be located in the same namespace as the class it shall test.</value>
  </data>
  <data name="MiKo_1407_MessageFormat" xml:space="preserve">
    <value>Remove 'Test' from namespace</value>
  </data>
  <data name="MiKo_1407_Title" xml:space="preserve">
    <value>Test namespaces should not contain 'Test'.</value>
  </data>
  <data name="MiKo_1408_Description" xml:space="preserve">
    <value>To ease usage, extension method classes should be placed in same namespace as the extended types.
That allows an easy detection and use via IntelliSense.</value>
  </data>
  <data name="MiKo_1408_MessageFormat" xml:space="preserve">
    <value>Place class in namespace '{1}'</value>
  </data>
  <data name="MiKo_1408_Title" xml:space="preserve">
    <value>Extension methods should be placed in same namespace as the extended types.</value>
  </data>
  <data name="MiKo_2000_Description" xml:space="preserve">
    <value>Documentation should be valid XML so that it can be generated as API documentation/IntelliSense to support the developers.</value>
  </data>
  <data name="MiKo_2000_MessageFormat" xml:space="preserve">
    <value>Documentation is malformed (contains invalid characters, eg. '&amp;', '&gt;', '&lt;')</value>
  </data>
  <data name="MiKo_2000_Title" xml:space="preserve">
    <value>Documentation should be valid XML.</value>
  </data>
  <data name="MiKo_2001_Description" xml:space="preserve">
    <value>Events should be documented with 'Occurs ...' to indicate that events actually occur.</value>
  </data>
  <data name="MiKo_2001_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2001_Title" xml:space="preserve">
    <value>Events should be documented properly.</value>
  </data>
  <data name="MiKo_2002_Description" xml:space="preserve">
    <value>To ease maintenance, classes that inherit from 'System.EventArgs' should be documented with 'Provides data for the &lt;see cref="XYZ" /&gt; event.' to indicate for which event they are valid.</value>
  </data>
  <data name="MiKo_2002_MessageFormat" xml:space="preserve">
    <value>&lt;summary&gt; documentation should follow pattern: '{1} ... {2}'</value>
  </data>
  <data name="MiKo_2002_Title" xml:space="preserve">
    <value>EventArgs should be documented properly.</value>
  </data>
  <data name="MiKo_2003_Description" xml:space="preserve">
    <value>Documentation of an event handler should have a default starting phrase that describes what event gets handled.</value>
  </data>
  <data name="MiKo_2003_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2003_Title" xml:space="preserve">
    <value>Documentation of event handlers should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2004_Description" xml:space="preserve">
    <value>Event method parameters should define what exactly they are.</value>
  </data>
  <data name="MiKo_2004_MessageFormat" xml:space="preserve">
    <value>Documentation should be: '{2}'</value>
  </data>
  <data name="MiKo_2004_Title" xml:space="preserve">
    <value>Documentation of parameter name does not follow .NET Framework Guidelines for event handlers.</value>
  </data>
  <data name="MiKo_2005_Description" xml:space="preserve">
    <value>Documentation should not contain the term 'event arg'. Instead, it should contain the reference to the specific class, such as '&lt;see cref="XyzEventArgs" /&gt;'.</value>
  </data>
  <data name="MiKo_2005_MessageFormat" xml:space="preserve">
    <value>Do not use term 'event arg'</value>
  </data>
  <data name="MiKo_2005_Title" xml:space="preserve">
    <value>Textual references to EventArgs should be documented properly.</value>
  </data>
  <data name="MiKo_2010_Description" xml:space="preserve">
    <value>To ease their usage when it comes to inheritance, sealed classes should document the fact that they are sealed.</value>
  </data>
  <data name="MiKo_2010_MessageFormat" xml:space="preserve">
    <value>End &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2010_Title" xml:space="preserve">
    <value>Sealed classes should document being sealed.</value>
  </data>
  <data name="MiKo_2011_Description" xml:space="preserve">
    <value>Unsealed classes should not report that they are sealed.</value>
  </data>
  <data name="MiKo_2011_MessageFormat" xml:space="preserve">
    <value>&lt;summary&gt; documentation should not contain: '{1}'</value>
  </data>
  <data name="MiKo_2011_Title" xml:space="preserve">
    <value>Unsealed classes should not lie about sealing.</value>
  </data>
  <data name="MiKo_2012_Description" xml:space="preserve">
    <value>To ease development and maintenance, the summary documentation should describe their responsibility.
It should not start with or contain a meaningless phrase like 'Used to'. Instead it should start with something more descriptive, such as: 'Allows to ', 'Represents ' or 'Provides '.</value>
  </data>
  <data name="MiKo_2012_MessageFormat" xml:space="preserve">
    <value>&lt;summary&gt; documentation should not {1} meaningless phrase: '{2}'</value>
  </data>
  <data name="MiKo_2012_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation should describe its responsibility.</value>
  </data>
  <data name="MiKo_2013_Description" xml:space="preserve">
    <value>To ease their usage, enums should specify what kind of values they define.</value>
  </data>
  <data name="MiKo_2013_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2013_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of Enums should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2014_Description" xml:space="preserve">
    <value>Dispose methods should be documented as by the .NET Framework.</value>
  </data>
  <data name="MiKo_2014_MessageFormat" xml:space="preserve">
    <value>Documentation should be: '{2}'</value>
  </data>
  <data name="MiKo_2014_Title" xml:space="preserve">
    <value>Dispose methods should be documented in the same way as they are documented by the .NET Framework.</value>
  </data>
  <data name="MiKo_2015_Description" xml:space="preserve">
    <value>The term 'Fire' is a negative term. Employees get fired (or guns), but not events or exceptions. Events get raised and exceptions get thrown.</value>
  </data>
  <data name="MiKo_2015_MessageFormat" xml:space="preserve">
    <value>Documentation should use {1} instead of {2}</value>
  </data>
  <data name="MiKo_2015_Title" xml:space="preserve">
    <value>Documentation should use 'raise' or 'throw' instead of 'fire'.</value>
  </data>
  <data name="MiKo_2016_Description" xml:space="preserve">
    <value>Documentation for asynchronous methods should indicate that method is run asynchronously.</value>
  </data>
  <data name="MiKo_2016_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2016_Title" xml:space="preserve">
    <value>Documentation for asynchronous methods should start with specific phrase.</value>
  </data>
  <data name="MiKo_2017_Description" xml:space="preserve">
    <value>Dependency properties should be documented in the same way as they are documented by the .NET Framework.</value>
  </data>
  <data name="MiKo_2017_MessageFormat" xml:space="preserve">
    <value>&lt;{2}&gt;documentation should be: '{3}'</value>
  </data>
  <data name="MiKo_2017_Title" xml:space="preserve">
    <value>Dependency properties should be documented as by the .NET Framework.</value>
  </data>
  <data name="MiKo_2018_Description" xml:space="preserve">
    <value>The term 'Check' is ambiguous. If validation of parameters is meant, use something like 'Validates' or 'Verifies'. If a check for a specific state is meant, use 'Determines' instead.</value>
  </data>
  <data name="MiKo_2018_MessageFormat" xml:space="preserve">
    <value>Do not use ambiguous term '{1}'</value>
  </data>
  <data name="MiKo_2018_Title" xml:space="preserve">
    <value>Documentation should not use the ambiguous term 'Check'.</value>
  </data>
  <data name="MiKo_2019_Description" xml:space="preserve">
    <value>&lt;summary&gt; documentation should start with a third person singular verb as it shall be a short description of the functionality that the class, property, etc. provides or represents.</value>
  </data>
  <data name="MiKo_2019_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with a third person singular verb</value>
  </data>
  <data name="MiKo_2019_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation should start with a third person singular verb (for example "Provides ").</value>
  </data>
  <data name="MiKo_2020_Description" xml:space="preserve">
    <value>It does not make sense to use a &lt;summary&gt; documentation that only reference something else via &lt;see cref="..." /&gt; as IntelliSense does not show these descriptions. For such a scenario &lt;inheritdoc /&gt; should be used.</value>
  </data>
  <data name="MiKo_2020_MessageFormat" xml:space="preserve">
    <value>Use &lt;inheritdoc /&gt; instead</value>
  </data>
  <data name="MiKo_2020_Title" xml:space="preserve">
    <value>Inherited documentation should be used with &lt;inheritdoc /&gt; marker.</value>
  </data>
  <data name="MiKo_2021_Description" xml:space="preserve">
    <value>The documentation of parameters should describe what they represent.</value>
  </data>
  <data name="MiKo_2021_MessageFormat" xml:space="preserve">
    <value>Start documentation with: {2}</value>
  </data>
  <data name="MiKo_2021_Title" xml:space="preserve">
    <value>Documentation of parameter should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2022_Description" xml:space="preserve">
    <value>The documentation of [out] parameters should start with the success case.</value>
  </data>
  <data name="MiKo_2022_MessageFormat" xml:space="preserve">
    <value>Start documentation with: {2}</value>
  </data>
  <data name="MiKo_2022_Title" xml:space="preserve">
    <value>Documentation of [out] parameters should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2023_Description" xml:space="preserve">
    <value>The documentation of a Boolean as parameter should have a specific phrase that first describes the 'true' case and then the 'false' case.</value>
  </data>
  <data name="MiKo_2023_MessageFormat" xml:space="preserve">
    <value>&lt;param name="{1}"&gt; documentation should follow pattern: '{2} ... {3}'</value>
  </data>
  <data name="MiKo_2023_Title" xml:space="preserve">
    <value>Documentation of Boolean parameters should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2024_Description" xml:space="preserve">
    <value>The documentation of Enum parameters should start with a phrase that specifies what will be done with the Enum.</value>
  </data>
  <data name="MiKo_2024_MessageFormat" xml:space="preserve">
    <value>&lt;param name="{1}"&gt; documentation should start with: {2}</value>
  </data>
  <data name="MiKo_2024_Title" xml:space="preserve">
    <value>Documentation of Enum parameters should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2025_Description" xml:space="preserve">
    <value>The documentation of 'CancellationToken' parameters should start with a phrase that describes how it is used.</value>
  </data>
  <data name="MiKo_2025_MessageFormat" xml:space="preserve">
    <value>&lt;param name="{1}"&gt; documentation should start with: {2}</value>
  </data>
  <data name="MiKo_2025_Title" xml:space="preserve">
    <value>Documentation of 'CancellationToken' parameters should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2030_Description" xml:space="preserve">
    <value>The documentation of a return value should have a default starting phrase that describes the returned value in more detail.</value>
  </data>
  <data name="MiKo_2030_MessageFormat" xml:space="preserve">
    <value>Start &lt;{2}&gt; with: '{3}'</value>
  </data>
  <data name="MiKo_2030_Title" xml:space="preserve">
    <value>Documentation of return value should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2031_Description" xml:space="preserve">
    <value>The documentation of a Task as return value should have a default (starting) phrase.</value>
  </data>
  <data name="MiKo_2031_MessageFormat" xml:space="preserve">
    <value>Start &lt;{2}&gt; with: '{3}'</value>
  </data>
  <data name="MiKo_2031_Title" xml:space="preserve">
    <value>Documentation of Task return value should have a specific (starting) phrase.</value>
  </data>
  <data name="MiKo_2032_Description" xml:space="preserve">
    <value>The documentation of a Boolean as return value should have a specific phrase that first describes the 'true' case and then the 'false' case.</value>
  </data>
  <data name="MiKo_2032_MessageFormat" xml:space="preserve">
    <value>&lt;{2}&gt; documentation should follow pattern: '{3} ... {4}'</value>
  </data>
  <data name="MiKo_2032_Title" xml:space="preserve">
    <value>Documentation of Boolean return value should have a specific phrase.</value>
  </data>
  <data name="MiKo_2033_Description" xml:space="preserve">
    <value>The documentation of a String as return value should have a specific phrase.</value>
  </data>
  <data name="MiKo_2033_MessageFormat" xml:space="preserve">
    <value>Start &lt;{2}&gt; with: '{3}'</value>
  </data>
  <data name="MiKo_2033_Title" xml:space="preserve">
    <value>Documentation of String return value should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2034_Description" xml:space="preserve">
    <value>The documentation of an Enum as return value should have a specific phrase.</value>
  </data>
  <data name="MiKo_2034_MessageFormat" xml:space="preserve">
    <value>Start &lt;{2}&gt; with: '{3}'</value>
  </data>
  <data name="MiKo_2034_Title" xml:space="preserve">
    <value>Documentation of Enum return value should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2035_Description" xml:space="preserve">
    <value>The documentation of a collection as return value should have a specific phrase.</value>
  </data>
  <data name="MiKo_2035_MessageFormat" xml:space="preserve">
    <value>Start &lt;{2}&gt; with: '{3}'</value>
  </data>
  <data name="MiKo_2035_Title" xml:space="preserve">
    <value>Documentation of collection return value should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2036_Description" xml:space="preserve">
    <value>The documentation of Boolean or Enum properties shall end with a phrase that describes the value that is returned per default.</value>
  </data>
  <data name="MiKo_2036_MessageFormat" xml:space="preserve">
    <value>End &lt;{2}&gt; with: '{3}'</value>
  </data>
  <data name="MiKo_2036_Title" xml:space="preserve">
    <value>Documentation of Boolean or Enum property shall describe the default value.</value>
  </data>
  <data name="MiKo_2037_Description" xml:space="preserve">
    <value>The documentation of a property that returns a command should start with a specific phrase that describes what command the property returns.</value>
  </data>
  <data name="MiKo_2037_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with: '{2}'</value>
  </data>
  <data name="MiKo_2037_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of command properties should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2038_Description" xml:space="preserve">
    <value>The documentation of a command should start with a specific phrase that describes what the command does.</value>
  </data>
  <data name="MiKo_2038_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with: '{2}'</value>
  </data>
  <data name="MiKo_2038_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of command should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2039_Description" xml:space="preserve">
    <value>The documentation of a class that contains extension methods should start with a specific phrase that describes what the class provides.</value>
  </data>
  <data name="MiKo_2039_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with: '{2}'</value>
  </data>
  <data name="MiKo_2039_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of classes that contain extension methods should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2040_Description" xml:space="preserve">
    <value>To support other languages than C#, use '&lt;see langword="..."/&gt;' instead of '&lt;c&gt;...&lt;/c&gt;'.</value>
  </data>
  <data name="MiKo_2040_MessageFormat" xml:space="preserve">
    <value>Use '{2}' instead of '{1}'</value>
  </data>
  <data name="MiKo_2040_Title" xml:space="preserve">
    <value>&lt;see langword="..."/&gt; should be used instead of &lt;c&gt;...&lt;/c&gt;.</value>
  </data>
  <data name="MiKo_2041_Description" xml:space="preserve">
    <value>The &lt;summary&gt; documentation should only contain a short summary description. Other documentation should be provided by the other tags in parallel to the &lt;summary&gt;.</value>
  </data>
  <data name="MiKo_2041_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/xmldoc/recommended-tags-for-documentation-comments</value>
  </data>
  <data name="MiKo_2041_MessageFormat" xml:space="preserve">
    <value>&lt;summary&gt; documentation should not contain: '{1}'</value>
  </data>
  <data name="MiKo_2041_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation should not contain other documentation tags.</value>
  </data>
  <data name="MiKo_2042_Description" xml:space="preserve">
    <value>The documentation should use the '&lt;para/&gt;' XML tags instead of '&lt;br/&gt;' HTML tags.</value>
  </data>
  <data name="MiKo_2042_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/xmldoc/para</value>
  </data>
  <data name="MiKo_2042_MessageFormat" xml:space="preserve">
    <value>Use '&lt;para/&gt;' instead of '&lt;br/&gt;'</value>
  </data>
  <data name="MiKo_2042_Title" xml:space="preserve">
    <value>Documentation should use '&lt;para/&gt;' XML tags instead of '&lt;br/&gt;' HTML tags.</value>
  </data>
  <data name="MiKo_2043_Description" xml:space="preserve">
    <value>The documentation of a custom delegate should have a default starting phrase to indicate what the delegate encapsulates.</value>
  </data>
  <data name="MiKo_2043_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with: '{2}'</value>
  </data>
  <data name="MiKo_2043_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of custom delegates should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2044_Description" xml:space="preserve">
    <value>Method parameters should be referenced via &lt;paramref name="..."/&gt; inside the documentation.</value>
  </data>
  <data name="MiKo_2044_MessageFormat" xml:space="preserve">
    <value>Fix incorrect parameter reference '{1}'</value>
  </data>
  <data name="MiKo_2044_Title" xml:space="preserve">
    <value>Documentation references method parameters correctly.</value>
  </data>
  <data name="MiKo_2045_Description" xml:space="preserve">
    <value>The &lt;summary&gt; documentation should not reference method parameters as its only purpose is to give a brief description.</value>
  </data>
  <data name="MiKo_2045_MessageFormat" xml:space="preserve">
    <value>&lt;summary&gt; documentation should not contain parameter reference: '{1}'</value>
  </data>
  <data name="MiKo_2045_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation should not reference parameters.</value>
  </data>
  <data name="MiKo_2046_Description" xml:space="preserve">
    <value>The XML documentation should reference type parameters properly via '&lt;typeparamref name="..." /&gt;'.</value>
  </data>
  <data name="MiKo_2046_MessageFormat" xml:space="preserve">
    <value>Replace invalid type parameter reference '{1}' by '{2}'</value>
  </data>
  <data name="MiKo_2046_Title" xml:space="preserve">
    <value>XML documentation should reference type parameters correctly.</value>
  </data>
  <data name="MiKo_2047_Description" xml:space="preserve">
    <value>The documentation of an Attribute should start with a specific phrase that describes its purpose.</value>
  </data>
  <data name="MiKo_2047_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with {1}</value>
  </data>
  <data name="MiKo_2047_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of Attributes should have a  default starting phrase.</value>
  </data>
  <data name="MiKo_2048_Description" xml:space="preserve">
    <value>The documentation of a value converters should start with a specific phrase that describes what they convert.</value>
  </data>
  <data name="MiKo_2048_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2048_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of value converters should have a  default starting phrase.</value>
  </data>
  <data name="MiKo_2049_Description" xml:space="preserve">
    <value>The term 'will be' is not explicit enough and it uses the wrong tense. Instead, a term such as 'is' gets to the point and uses present tense.</value>
  </data>
  <data name="MiKo_2049_MessageFormat" xml:space="preserve">
    <value>Documentation should use 'is' instead of 'will be'</value>
  </data>
  <data name="MiKo_2049_Title" xml:space="preserve">
    <value>Documentation should be more explicit and not use 'will be'.</value>
  </data>
  <data name="MiKo_2050_Description" xml:space="preserve">
    <value>The documentation of exceptions should follow the .NET Framework documentation.</value>
  </data>
  <data name="MiKo_2050_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with: '{2}'</value>
  </data>
  <data name="MiKo_2050_Title" xml:space="preserve">
    <value>Exceptions should be documented following the .NET Framework.</value>
  </data>
  <data name="MiKo_2051_Description" xml:space="preserve">
    <value>The documentation of a thrown exception should be a simple condition phrase, such as: 'The item is not available'.</value>
  </data>
  <data name="MiKo_2051_MessageFormat" xml:space="preserve">
    <value>Use condition form to document thrown exception</value>
  </data>
  <data name="MiKo_2051_Title" xml:space="preserve">
    <value>Thrown Exceptions should be documented as kind of a condition (such as '&lt;paramref name="xyz"/&gt; is &lt;c&gt;42&lt;/c&gt;').</value>
  </data>
  <data name="MiKo_2052_Description" xml:space="preserve">
    <value>The documentation of an ArgumentNullException being thrown should be a specific phrase.</value>
  </data>
  <data name="MiKo_2052_MessageFormat" xml:space="preserve">
    <value>{1} documentation should be something like:

{2}</value>
  </data>
  <data name="MiKo_2052_Title" xml:space="preserve">
    <value>Throwing of ArgumentNullException should be documented using a default phrase.</value>
  </data>
  <data name="MiKo_2053_Description" xml:space="preserve">
    <value>The documentation of an ArgumentNullException should not refer to a value type parameter as that can never be null.</value>
  </data>
  <data name="MiKo_2053_MessageFormat" xml:space="preserve">
    <value>Remove '{2}' from &lt;exception cref="ArgumentNullException"/&gt; as '{1}' is a value type</value>
  </data>
  <data name="MiKo_2053_Title" xml:space="preserve">
    <value>Throwing of ArgumentNullException should be documented only for reference type parameters.</value>
  </data>
  <data name="MiKo_2054_Description" xml:space="preserve">
    <value>The documentation of an ArgumentException being thrown should have a specific starting phrase.</value>
  </data>
  <data name="MiKo_2054_MessageFormat" xml:space="preserve">
    <value>{1} documentation should be something like:
{2}</value>
  </data>
  <data name="MiKo_2054_Title" xml:space="preserve">
    <value>Throwing of ArgumentException should be documented using a default starting phrase.</value>
  </data>
  <data name="MiKo_2055_Description" xml:space="preserve">
    <value>The documentation of an ArgumentOutOfRangeException being thrown should have a specific starting phrase.</value>
  </data>
  <data name="MiKo_2055_MessageFormat" xml:space="preserve">
    <value>{1} documentation should be something like:
{2}</value>
  </data>
  <data name="MiKo_2055_Title" xml:space="preserve">
    <value>Throwing of ArgumentOutOfRangeException should be documented using a default starting phrase.</value>
  </data>
  <data name="MiKo_2056_Description" xml:space="preserve">
    <value>The documentation of an ObjectDisposedException being thrown should have a specific ending phrase.</value>
  </data>
  <data name="MiKo_2056_MessageFormat" xml:space="preserve">
    <value>{1} documentation should end with: '{2}'</value>
  </data>
  <data name="MiKo_2056_Title" xml:space="preserve">
    <value>Throwing of ObjectDisposedException should be documented using a default ending phrase.</value>
  </data>
  <data name="MiKo_2057_Description" xml:space="preserve">
    <value>Types that do not inherit from 'IDisposable' cannot be disposed. Hence they shall not throw an ObjectDisposedException.</value>
  </data>
  <data name="MiKo_2057_MessageFormat" xml:space="preserve">
    <value>Remove '{1}' because type does not inherit from 'IDisposable'</value>
  </data>
  <data name="MiKo_2057_Title" xml:space="preserve">
    <value>Types that are not disposable shall not throw an ObjectDisposedException.</value>
  </data>
  <data name="MiKo_2060_Description" xml:space="preserve">
    <value>The documentation of factories should be uniform and consistent.</value>
  </data>
  <data name="MiKo_2060_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2060_Title" xml:space="preserve">
    <value>Factories should be documented in a uniform way.</value>
  </data>
  <data name="MiKo_2070_Description" xml:space="preserve">
    <value>If a method comment starts with 'Returns', then it focuses on the return value but not on the purpose (responsibility) of the method.
Instead, the documentation should describe what the method is intended to do.</value>
  </data>
  <data name="MiKo_2070_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2070_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation should not start with 'Returns'.</value>
  </data>
  <data name="MiKo_2071_Description" xml:space="preserve">
    <value>Enum types are no boolean values. Hence the documentation should not contain any phrase that would handle enums as if they were booleans (such as it would be the case in phrase 'indicates whether').</value>
  </data>
  <data name="MiKo_2071_MessageFormat" xml:space="preserve">
    <value>Do not use phrase '{1}' in &lt;summary&gt; documentation</value>
  </data>
  <data name="MiKo_2071_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation for methods that return Enum types should not contain phrase for boolean type.</value>
  </data>
  <data name="MiKo_2072_Description" xml:space="preserve">
    <value>'Try' methods attempt to acchieve something. So their &lt;summary&gt; documentation should start with the phrase 'Attempts to'.</value>
  </data>
  <data name="MiKo_2072_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2072_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation should not start with 'Try'.</value>
  </data>
  <data name="MiKo_2073_Description" xml:space="preserve">
    <value>'Contain' methods attempt to determine if something exists inside something else. So their &lt;summary&gt; documentation should start with the phrase 'Determines '.</value>
  </data>
  <data name="MiKo_2073_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2073_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of 'Contains' methods should start with 'Determines '.</value>
  </data>
  <data name="MiKo_2074_Description" xml:space="preserve">
    <value>'Contain' methods attempt to determine if the value of a given parameter exists inside something. So the &lt;param&gt; documentation of the given parameter should end with the phrase ' to seek.'.</value>
  </data>
  <data name="MiKo_2074_MessageFormat" xml:space="preserve">
    <value>&lt;param name="{1}"&gt; documentation should end with: '{2}'</value>
  </data>
  <data name="MiKo_2074_Title" xml:space="preserve">
    <value>Documentation of parameter of 'Contains' method should have a default ending phrase.</value>
  </data>
  <data name="MiKo_2080_Description" xml:space="preserve">
    <value>The documentation of fields should start with a default phrase.</value>
  </data>
  <data name="MiKo_2080_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2080_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of fields should have a default starting phrase.</value>
  </data>
  <data name="MiKo_2081_Description" xml:space="preserve">
    <value>The documentation of a public-visible read-only field should indicate that it is read-only.</value>
  </data>
  <data name="MiKo_2081_MessageFormat" xml:space="preserve">
    <value>End &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2081_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of public-visible read-only fields should have a default ending phrase.</value>
  </data>
  <data name="MiKo_2100_Description" xml:space="preserve">
    <value>To ease usage, the example documentation should start with a phrase that shortly describes what the given example demonstrates.</value>
  </data>
  <data name="MiKo_2100_MessageFormat" xml:space="preserve">
    <value>Start &lt;example&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2100_Title" xml:space="preserve">
    <value>&lt;example&gt; documentation should start with descriptive default phrase.</value>
  </data>
  <data name="MiKo_2200_Description" xml:space="preserve">
    <value>Documentation should start with a capitalized letter to have a full sentence.</value>
  </data>
  <data name="MiKo_2200_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with capitalized letter</value>
  </data>
  <data name="MiKo_2200_Title" xml:space="preserve">
    <value>Use a capitalized letter to start the comment.</value>
  </data>
  <data name="MiKo_2201_Description" xml:space="preserve">
    <value>The XML documentation should not use the abbreviation 'guid'. Instead, it should clearly document that this is an unique identifier. Hence, it should use the term 'unique identifier' instead.</value>
  </data>
  <data name="MiKo_2201_MessageFormat" xml:space="preserve">
    <value>Use 'unique identifier' instead of 'guid' in documentation</value>
  </data>
  <data name="MiKo_2201_Title" xml:space="preserve">
    <value>Documentation should use the term 'unique identifier' instead of 'guid'.</value>
  </data>
  <data name="MiKo_2202_Description" xml:space="preserve">
    <value>The XML documentation should not use the abbreviation 'id'. Instead, it should clearly document that this is an identifier. Hence, it should use the term 'identifier' instead.</value>
  </data>
  <data name="MiKo_2202_MessageFormat" xml:space="preserve">
    <value>Use 'identifier' instead of 'id' in documentation</value>
  </data>
  <data name="MiKo_2202_Title" xml:space="preserve">
    <value>Documentation should use the term 'identifier' instead of 'id'.</value>
  </data>
  <data name="MiKo_2203_Description" xml:space="preserve">
    <value>The XML documentation should use the &lt;list&gt; XML tag if things get enumerated. It should not use terms such as 1), 2) etc. directly.
This is because IntelliSense or any XML documentation tool are not aware of such terms and therefore the comment will become strangely formatted.</value>
  </data>
  <data name="MiKo_2203_MessageFormat" xml:space="preserve">
    <value>Use &lt;list&gt; for enumeration in documentation</value>
  </data>
  <data name="MiKo_2203_Title" xml:space="preserve">
    <value>Documentation should use &lt;list&gt; for enumerations.</value>
  </data>
  <data name="MiKo_2204_Description" xml:space="preserve">
    <value>The XML documentation should use the &lt;note&gt; XML tag to mark important information. It should not use terms such as 'Important' or 'Attention' directly.
This is because XML documentation tools are aware of &lt;note&gt; and can format the information in a special way.</value>
  </data>
  <data name="MiKo_2204_MessageFormat" xml:space="preserve">
    <value>Use &lt;note&gt; for important information in documentation</value>
  </data>
  <data name="MiKo_2204_Title" xml:space="preserve">
    <value>Documentation should use &lt;note&gt; for important information.</value>
  </data>
  <data name="MiKo_2205_Description" xml:space="preserve">
    <value>The documentation should not use the term 'flag' which is often used to describe a boolean value. Instead, the documentation should be re-phrased so that the term is no longer necessary.</value>
  </data>
  <data name="MiKo_2205_MessageFormat" xml:space="preserve">
    <value>Remove '{1}' from documentation</value>
  </data>
  <data name="MiKo_2205_Title" xml:space="preserve">
    <value>Documentation should not use the term 'flag'.</value>
  </data>
  <data name="MiKo_3000_Description" xml:space="preserve">
    <value>If #region shall be used, then any empty #region shall be avoided.
Such empty regions solely clutter the code without providing any benefit at all.</value>
  </data>
  <data name="MiKo_3000_MessageFormat" xml:space="preserve">
    <value>Remove empty {0}</value>
  </data>
  <data name="MiKo_3000_Title" xml:space="preserve">
    <value>Do not use empty regions.</value>
  </data>
  <data name="MiKo_3001_Description" xml:space="preserve">
    <value>To ease maintenance, use the pre-defined .NET Framework delegate types such as 'Action', 'Func' or 'Expression' instead of custom delegates.</value>
  </data>
  <data name="MiKo_3001_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/events-and-callbacks</value>
  </data>
  <data name="MiKo_3001_MessageFormat" xml:space="preserve">
    <value>Use 'Action', 'Func' or 'Expression' instead</value>
  </data>
  <data name="MiKo_3001_Title" xml:space="preserve">
    <value>Custom delegates should not be used.</value>
  </data>
  <data name="MiKo_3002_Description" xml:space="preserve">
    <value>If a class has too many dependencies, that class is doing too much and does not follow the SRP.</value>
  </data>
  <data name="MiKo_3002_MessageFormat" xml:space="preserve">
    <value>Too many MEF dependencies: {1,4} (max. {2})</value>
  </data>
  <data name="MiKo_3002_Title" xml:space="preserve">
    <value>Classes should not have too many dependencies.</value>
  </data>
  <data name="MiKo_3003_Description" xml:space="preserve">
    <value>To ease usage, events should follow the .NET Framework Guidelines for Event Design.</value>
  </data>
  <data name="MiKo_3003_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/event</value>
  </data>
  <data name="MiKo_3003_MessageFormat" xml:space="preserve">
    <value>Use 'EventHandler' or 'EventHandler&lt;T&gt;'</value>
  </data>
  <data name="MiKo_3003_Title" xml:space="preserve">
    <value>Events should follow .NET Framework Guidelines for events.</value>
  </data>
  <data name="MiKo_3004_Description" xml:space="preserve">
    <value>EventArgs exist only to raise events and to pass some data that to the listening event handlers.
If the carried event data now changes between the different handlers, the behavior gets unpredictable and a race condition occurs.

To avoid that situation, the properties of EventArgs shall be read-only or only privately settable. If you have to set the event data, provide a method to do so and ensure that the method acts as circuit breaker (that is you can set the data exactly once).</value>
  </data>
  <data name="MiKo_3004_MessageFormat" xml:space="preserve">
    <value>Make setter private or property read-only</value>
  </data>
  <data name="MiKo_3004_Title" xml:space="preserve">
    <value>Property setters of EventArgs shall be private.</value>
  </data>
  <data name="MiKo_3005_Description" xml:space="preserve">
    <value>To ease maintenance, methods that are named 'Try' should follow the Trier-Doer-Pattern.

That is they should return a Boolean and have the last parameter as [out] parameter for the result. In the success case the method should return 'true' and provide valid out data; in all other cases the method should return 'false'.</value>
  </data>
  <data name="MiKo_3005_MessageFormat" xml:space="preserve">
    <value>Follow the Trier-Doer-Pattern</value>
  </data>
  <data name="MiKo_3005_Title" xml:space="preserve">
    <value>Methods named 'Try' should follow the Trier-Doer-Pattern.</value>
  </data>
  <data name="MiKo_3006_Description" xml:space="preserve">
    <value>To ease maintenance, and being consistent with the .NET Framework classes, 'CancellationToken' parameters should come after all the other parameters of a method.</value>
  </data>
  <data name="MiKo_3006_MessageFormat" xml:space="preserve">
    <value>'{0}' should be last parameter</value>
  </data>
  <data name="MiKo_3006_Title" xml:space="preserve">
    <value>'CancellationToken' parameter should be last method parameter.</value>
  </data>
  <data name="MiKo_3007_Description" xml:space="preserve">
    <value>To ease maintainability and readability, methods should be written using only one single language. Hence LINQ method syntax and declarative query syntax should not be used within the same method.</value>
  </data>
  <data name="MiKo_3007_MessageFormat" xml:space="preserve">
    <value>Do not mix LINQ syntax</value>
  </data>
  <data name="MiKo_3007_Title" xml:space="preserve">
    <value>Do not use LINQ method and declarative query syntax in same method.</value>
  </data>
  <data name="MiKo_3008_Description" xml:space="preserve">
    <value>Methods should not return changeable collections such as 'ICollection&lt;T&gt;' because those can be changed from outside. Instead they should return the read-only variants (e.g. 'IReadOnlyCollection&lt;T&gt;').</value>
  </data>
  <data name="MiKo_3008_MessageFormat" xml:space="preserve">
    <value>Use a read-only immutable variant or 'IEnumerable&lt;T&gt;' instead</value>
  </data>
  <data name="MiKo_3008_Title" xml:space="preserve">
    <value>Method should not return collections that can be changed from outside.</value>
  </data>
  <data name="MiKo_3009_Description" xml:space="preserve">
    <value>Methods that are invoked by commands should not be lambda expressions as that makes them hard to read, understand and maintain. Instead they should be named methods that have a meaningful name.</value>
  </data>
  <data name="MiKo_3009_MessageFormat" xml:space="preserve">
    <value>Use named method instead</value>
  </data>
  <data name="MiKo_3009_Title" xml:space="preserve">
    <value>Commands should invoke only named methods and no lambda expressions.</value>
  </data>
  <data name="MiKo_3010_Description" xml:space="preserve">
    <value>Specific kinds of exceptions are reserved and thrown by the execution engine (CLR) and in most cases indicate a bug.</value>
  </data>
  <data name="MiKo_3010_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/using-standard-exception-types</value>
  </data>
  <data name="MiKo_3010_MessageFormat" xml:space="preserve">
    <value>Do not create a '{0}'</value>
  </data>
  <data name="MiKo_3010_Title" xml:space="preserve">
    <value>Do not create or throw reserved exception types.</value>
  </data>
  <data name="MiKo_3011_Description" xml:space="preserve">
    <value>Thrown ArgumentExceptions (or its subtypes) should contain the name of the parameter that caused the exception to be thrown.</value>
  </data>
  <data name="MiKo_3011_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/using-standard-exception-types#argumentexception-argumentnullexception-and-argumentoutofrangeexception</value>
  </data>
  <data name="MiKo_3011_MessageFormat" xml:space="preserve">
    <value>Set 'paramName' parameter to {1}</value>
  </data>
  <data name="MiKo_3011_Title" xml:space="preserve">
    <value>Thrown ArgumentExceptions (or its subtypes) shall provide the correct parameter name.</value>
  </data>
  <data name="MiKo_3012_Description" xml:space="preserve">
    <value>Thrown ArgumentOutOfRangeExceptions (or its subtypes) should contain the actual value of the parameter that caused the exception to be thrown.</value>
  </data>
  <data name="MiKo_3012_MessageFormat" xml:space="preserve">
    <value>Provide the actual value that causes the exception to be thrown</value>
  </data>
  <data name="MiKo_3012_Title" xml:space="preserve">
    <value>Thrown ArgumentOutOfRangeExceptions (or its subtypes) shall provide the actual value that causes the exception to be thrown.</value>
  </data>
  <data name="MiKo_3013_Description" xml:space="preserve">
    <value>The 'default' clause in 'switch' statements should throw an ArgumentOutOfRangeException (or subtype) to indicate that the given argument is out of range, but no ArgumentException.</value>
  </data>
  <data name="MiKo_3013_MessageFormat" xml:space="preserve">
    <value>Throw an 'ArgumentOutOfRangeException' instead</value>
  </data>
  <data name="MiKo_3013_Title" xml:space="preserve">
    <value>The 'default' clause in 'switch' statements should throw an ArgumentOutOfRangeException (or subtype), but no ArgumentException.</value>
  </data>
  <data name="MiKo_3014_Description" xml:space="preserve">
    <value>To ease maintenance, a thrown InvalidOperationException, NotImplementedException or NotSupportedException should have a reason that explains the circumstances why the exception has been thrown and - ideally - how to solve the situation.</value>
  </data>
  <data name="MiKo_3014_MessageFormat" xml:space="preserve">
    <value>Provide a reason why the '{0}' is thrown</value>
  </data>
  <data name="MiKo_3014_Title" xml:space="preserve">
    <value>InvalidOperationException, NotImplementedException and NotSupportedException should have a reason as message.</value>
  </data>
  <data name="MiKo_3015_Description" xml:space="preserve">
    <value>ArgumentExceptions (or its subtypes) should not be thrown by parameterless methods.</value>
  </data>
  <data name="MiKo_3015_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/using-standard-exception-types</value>
  </data>
  <data name="MiKo_3015_MessageFormat" xml:space="preserve">
    <value>Throw an 'InvalidOperationException' instead</value>
  </data>
  <data name="MiKo_3015_Title" xml:space="preserve">
    <value>Parameterless methods should throw InvalidOperationExceptions (instead of ArgumentExceptions or its subtypes) to indicate inappropriate states.</value>
  </data>
  <data name="MiKo_3020_Description" xml:space="preserve">
    <value>For performance reasons it's better to use 'Task.CompletedTask' instead of 'Task.FromResult()' as the returned task is internally cached.</value>
  </data>
  <data name="MiKo_3020_MessageFormat" xml:space="preserve">
    <value>Use 'Task.CompletedTask' instead</value>
  </data>
  <data name="MiKo_3020_Title" xml:space="preserve">
    <value>Use 'Task.CompletedTask' instead of 'Task.FromResult'.</value>
  </data>
  <data name="MiKo_3021_Description" xml:space="preserve">
    <value>If you use 'Task.Run' to return a Task because a method is a long-running operation, then this most probably means that you've doing something wrong. If you have a long-running operation, use 'Task.Run' to call it.</value>
  </data>
  <data name="MiKo_3021_HelpLinkUri" xml:space="preserve">
    <value>https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html</value>
  </data>
  <data name="MiKo_3021_MessageFormat" xml:space="preserve">
    <value>Use '{0}' to invoke method '{1}', but not inside</value>
  </data>
  <data name="MiKo_3021_Title" xml:space="preserve">
    <value>Do not use 'Task.Run' in the implementation.</value>
  </data>
  <data name="MiKo_3022_Description" xml:space="preserve">
    <value>If a method returns Task&lt;IEnumerable&gt; or Task&lt;IEnumerable&lt;T&gt;&gt;, then it is likely that the enumerable is not evaluated until it is accessed in a foreach or Linq call.
That accessor likely is another thread (e.g. the main thread) which contradicts the whole idea of returning a dedicated task.</value>
  </data>
  <data name="MiKo_3022_MessageFormat" xml:space="preserve">
    <value>Do not return '{1}'</value>
  </data>
  <data name="MiKo_3022_Title" xml:space="preserve">
    <value>Do not return Task&lt;IEnumerable&gt; or Task&lt;IEnumerable&lt;T&gt;&gt;.</value>
  </data>
  <data name="MiKo_3023_Description" xml:space="preserve">
    <value>A 'CancellationTokenSource' should not be passed around. Instead, the 'CancellationToken' should be passed around to propagate notifications that operations should be canceled.</value>
  </data>
  <data name="MiKo_3023_MessageFormat" xml:space="preserve">
    <value>Use a '{1}' instead</value>
  </data>
  <data name="MiKo_3023_Title" xml:space="preserve">
    <value>Do not use 'CancellationTokenSource' as parameter.</value>
  </data>
  <data name="MiKo_3024_Description" xml:space="preserve">
    <value>[ref] allows to change the storage location of the variable it is declared on. This allows to re-assign values to an already existing variable and therefore altering it.
In case of reference types the altered variable is an altered object reference, thus all callees that access the altered variable later on get the changed one (very similar to an out parameter).

In most cases this is not wanted. The object reference shall be the same, only the object shall be altered.</value>
  </data>
  <data name="MiKo_3024_MessageFormat" xml:space="preserve">
    <value>Do not use 'ref'</value>
  </data>
  <data name="MiKo_3024_Title" xml:space="preserve">
    <value>Do not use the [ref] keyword on reference parameters.</value>
  </data>
  <data name="MiKo_3025_Description" xml:space="preserve">
    <value>Method parameters should be considered as read-only. They should not be re-assigned to other values. If you need them to have another value, use a local variable instead.</value>
  </data>
  <data name="MiKo_3025_MessageFormat" xml:space="preserve">
    <value>Do not re-assign '{0}'</value>
  </data>
  <data name="MiKo_3025_Title" xml:space="preserve">
    <value>Do not re-assign method parameters.</value>
  </data>
  <data name="MiKo_3026_Description" xml:space="preserve">
    <value>Unused parameters are not needed and should be removed as they solely clutter the code base without providing any benefit at all.</value>
  </data>
  <data name="MiKo_3026_MessageFormat" xml:space="preserve">
    <value>Parameter '{0}' is not used and can be safely removed</value>
  </data>
  <data name="MiKo_3026_Title" xml:space="preserve">
    <value>Unused parameters should be removed.</value>
  </data>
  <data name="MiKo_3030_Description" xml:space="preserve">
    <value>For performance reasons, it makes no sense to use 'object.Equals()' on value types. Value types get boxed and unboxed when being casted to objects. That puts unnecessary pressure on the garbage collector as temporary objects are created and immediately get garbage collected.

Instead the equality operator should be used to compare value types.</value>
  </data>
  <data name="MiKo_3030_MessageFormat" xml:space="preserve">
    <value>Use '==' operator instead of 'object.Equals'</value>
  </data>
  <data name="MiKo_3030_Title" xml:space="preserve">
    <value>Do not use 'object.Equals()' on value types.</value>
  </data>
  <data name="MiKo_3031_Description" xml:space="preserve">
    <value>For performance reasons (and to avoid large pressure on the garbage collector) strings should be concatenated with 'string.Concat()', 'string.Join()' or by using a 'StringBuilder'.</value>
  </data>
  <data name="MiKo_3031_MessageFormat" xml:space="preserve">
    <value>Use 'string.Concat()' or 'string.Join()' instead</value>
  </data>
  <data name="MiKo_3031_Title" xml:space="preserve">
    <value>Do not concatenate strings with += operator.</value>
  </data>
  <data name="MiKo_3032_Description" xml:space="preserve">
    <value>The ICloneable.Clone() method does not define whether a deep or a swallow copy shall be returned.

As that is not defined, there is no guarantee how it gets implemented, and - because of that - it simply cannot be used as there is a huge difference between a deep and a swallow copy.</value>
  </data>
  <data name="MiKo_3032_MessageFormat" xml:space="preserve">
    <value>Do not implement 'ICloneable.Clone()'</value>
  </data>
  <data name="MiKo_3032_Title" xml:space="preserve">
    <value>ICloneable.Clone() should not be implemented.</value>
  </data>
  <data name="MiKo_3033_Description" xml:space="preserve">
    <value>Property names that are passed into the  'PropertyChangingEventArgs' and 'PropertyChangedEventArgs' constructors shall be provided via the 'nameof' operator. This prevents typos or non-existing invalid names and eases refactorings.</value>
  </data>
  <data name="MiKo_3033_MessageFormat" xml:space="preserve">
    <value>Use 'nameof' instead</value>
  </data>
  <data name="MiKo_3033_Title" xml:space="preserve">
    <value>Property names for created 'PropertyChangingEventArgs' and 'PropertyChangedEventArgs' instances shall be provided via 'nameof' operator.</value>
  </data>
  <data name="MiKo_3040_Description" xml:space="preserve">
    <value>To ease maintenance and increase readability, do not use Booleans unless you are absolutely sure there will never be a need for more than two values. Instead, use an Enum.</value>
  </data>
  <data name="MiKo_3040_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/parameter-design</value>
  </data>
  <data name="MiKo_3040_MessageFormat" xml:space="preserve">
    <value>Use an Enum instead</value>
  </data>
  <data name="MiKo_3040_Title" xml:space="preserve">
    <value>Do not use Booleans unless you are absolutely sure there will never be a need for more than two values.</value>
  </data>
  <data name="MiKo_3041_Description" xml:space="preserve">
    <value>EventArgs should not use delegates such as 'Action' or 'Func' because the callee needs to know exactly how the delegate behaves.
Failures inside the delegate(s) are really hard to tackle down because an exception gets thrown at a completely unrelated area.</value>
  </data>
  <data name="MiKo_3041_MessageFormat" xml:space="preserve">
    <value>Do not use a delegate</value>
  </data>
  <data name="MiKo_3041_Title" xml:space="preserve">
    <value>EventArgs shall not use delegates.</value>
  </data>
  <data name="MiKo_3050_Description" xml:space="preserve">
    <value>Fields that are the back of a DependencyProperty should be made 'public static readonly' to allow the .NET framework and other clients to find and access those fields.</value>
  </data>
  <data name="MiKo_3050_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/how-to-implement-a-dependency-property</value>
  </data>
  <data name="MiKo_3050_MessageFormat" xml:space="preserve">
    <value>Make it 'public static readonly'</value>
  </data>
  <data name="MiKo_3050_Title" xml:space="preserve">
    <value>DependencyProperty fields should be 'public static readonly'.</value>
  </data>
  <data name="MiKo_3051_Description" xml:space="preserve">
    <value>To avoid typos, fields that are the back of a DependencyProperty should be registered via 'DependencyProperty.Register()' and the 'nameof' operator.
In addition, the correct property names, property types and owing types should be provided.</value>
  </data>
  <data name="MiKo_3051_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/how-to-implement-a-dependency-property</value>
  </data>
  <data name="MiKo_3051_MessageFormat" xml:space="preserve">
    <value>Use '{1}' instead</value>
  </data>
  <data name="MiKo_3051_Title" xml:space="preserve">
    <value>DependencyProperty fields should be properly registered.</value>
  </data>
  <data name="MiKo_3052_Description" xml:space="preserve">
    <value>Fields that are the back of a DependencyPropertyKey should be made non-public, 'static readonly' to prevent clients to find and access those fields.</value>
  </data>
  <data name="MiKo_3052_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/api/system.windows.dependencypropertykey</value>
  </data>
  <data name="MiKo_3052_MessageFormat" xml:space="preserve">
    <value>Make it non-public 'static readonly'</value>
  </data>
  <data name="MiKo_3052_Title" xml:space="preserve">
    <value>DependencyPropertyKey fields should be non-public 'static readonly'.</value>
  </data>
  <data name="MiKo_3053_Description" xml:space="preserve">
    <value>To avoid typos, fields that are the Key of a DependencyProperty should be registered via 'DependencyProperty.RegisterReadOnly()' and the 'nameof' operator.
In addition, the correct property names, property types and owing types should be provided.</value>
  </data>
  <data name="MiKo_3053_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/api/system.windows.dependencyproperty.registerreadonly</value>
  </data>
  <data name="MiKo_3053_MessageFormat" xml:space="preserve">
    <value>Use '{1}' instead</value>
  </data>
  <data name="MiKo_3053_Title" xml:space="preserve">
    <value>DependencyPropertyKey fields should be properly registered.</value>
  </data>
  <data name="MiKo_3054_Description" xml:space="preserve">
    <value>Read-only dependency properties are defined by 'DependencyPropertyKey' fields and should not be visible to the public.
To made them available, it is recommended to expose a dependency property identifier for such read-only dependency property.
That can be done by exposing the value of 'DependencyPropertyKey.DependencyProperty' as a 'public static readonly' field on the specific class.</value>
  </data>
  <data name="MiKo_3054_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/api/system.windows.dependencyproperty.registerreadonly</value>
  </data>
  <data name="MiKo_3054_MessageFormat" xml:space="preserve">
    <value>Expose a DependencyProperty identifier for the read-only dependency property '{0}'</value>
  </data>
  <data name="MiKo_3054_Title" xml:space="preserve">
    <value>A read-only DependencyProperty should have an exposed DependencyProperty identifier.</value>
  </data>
  <data name="MiKo_3060_Description" xml:space="preserve">
    <value>If you use Debug.Assert() or Trace.Assert(), then you want to ensure something. Nevertheless, this has several drawbacks:
1. Debug.Assert() does not work in Release mode (whereas Trace.Assert() does).
2. You cannot do anything here except to confirm the situation.
3. There is no failure handling available.
4. Calling code is not informed about the code and cannot handle the situation properly.

So instead of using Debug.Assert() or Trace.Assert() throw an exception, such as an InvalidOperationException.

Especially never use Debug.Assert() or Trace.Assert() in (unit) test code. That's why the test code is there. Let the test fail in a case were Debug.Assert() or Trace.Assert() would apply.</value>
  </data>
  <data name="MiKo_3060_MessageFormat" xml:space="preserve">
    <value>Do not use '{1}'</value>
  </data>
  <data name="MiKo_3060_Title" xml:space="preserve">
    <value>Debug.Assert or Trace.Assert shall not be used.</value>
  </data>
  <data name="MiKo_3100_Description" xml:space="preserve">
    <value>To ease maintenance, test classes should be in the exact same namespace as the class they test.
This allows easy usage without any arbitrary using directives. It also mimics the project structure and makes the discoverability of the tests much easier.</value>
  </data>
  <data name="MiKo_3100_MessageFormat" xml:space="preserve">
    <value>Place test class in namespace '{1}'</value>
  </data>
  <data name="MiKo_3100_Title" xml:space="preserve">
    <value>Test classes and types under test belong in same namespace.</value>
  </data>
  <data name="MiKo_3101_Description" xml:space="preserve">
    <value>A class that is marked as a unit test class should contain unit tests.</value>
  </data>
  <data name="MiKo_3101_MessageFormat" xml:space="preserve">
    <value>'{0}' should contain tests</value>
  </data>
  <data name="MiKo_3101_Title" xml:space="preserve">
    <value>Test classes should contain tests.</value>
  </data>
  <data name="MiKo_3102_Description" xml:space="preserve">
    <value>Tests should test a very specific scenario. Therefore there is no need to have a condition, because in that situation a test tests more than one scenario.
So having a condition inside a test is a huge code smell.</value>
  </data>
  <data name="MiKo_3102_MessageFormat" xml:space="preserve">
    <value>Refactor test to remove condition</value>
  </data>
  <data name="MiKo_3102_Title" xml:space="preserve">
    <value>Test methods should not contain conditional statements such as 'if', 'switch', etc.</value>
  </data>
  <data name="MiKo_3103_Description" xml:space="preserve">
    <value>Tests should be specific to make them reproducible and easy to maintain. A GUID that is generated is not reproducible at all and cannot be easily found in case a test fails.
Therefore, a hard-coded GUID should be used instead.</value>
  </data>
  <data name="MiKo_3103_MessageFormat" xml:space="preserve">
    <value>Use a hard-coded GUID instead</value>
  </data>
  <data name="MiKo_3103_Title" xml:space="preserve">
    <value>Test methods should not use 'Guid.NewGuid()'.</value>
  </data>
  <data name="MiKo_3104_Description" xml:space="preserve">
    <value>NUnit's [Combinatorial] attribute shall be used only if there is a test method that has at least 2 parameters to create the combinatorial. Otherwise there is no reason to mark a test with that attribute.</value>
  </data>
  <data name="MiKo_3104_MessageFormat" xml:space="preserve">
    <value>Wrong usage of [Combinatorial]</value>
  </data>
  <data name="MiKo_3104_Title" xml:space="preserve">
    <value>Use NUnit's [Combinatorial] attribute properly.</value>
  </data>
  <data name="MiKo_3401_Description" xml:space="preserve">
    <value>Namespaces should have only a limited depth. If a namespace hierarchy becomes too deep, then the namespaces are probably too concrete or special to make sense.
Such namespaces should be flattened.</value>
  </data>
  <data name="MiKo_3401_MessageFormat" xml:space="preserve">
    <value>Namespace hierarchy too deep: {1,4} (max. {2})</value>
  </data>
  <data name="MiKo_3401_Title" xml:space="preserve">
    <value>Namespace hierarchies should not be too deep.</value>
  </data>
  <data name="MiKo_4101_Description" xml:space="preserve">
    <value>Test initialization method define the most common parts that tests shall contain. So to ease their finding they should be ordered first.</value>
  </data>
  <data name="MiKo_4101_MessageFormat" xml:space="preserve">
    <value>Place test initialization method before all other methods</value>
  </data>
  <data name="MiKo_4101_Title" xml:space="preserve">
    <value>Test initialization methods should be ordered first.</value>
  </data>
  <data name="MiKo_4102_Description" xml:space="preserve">
    <value>Test cleanup methods define the common parts that shall be executed after any test has been finished. So to ease their finding they should be ordered before the test methods.</value>
  </data>
  <data name="MiKo_4102_MessageFormat" xml:space="preserve">
    <value>Place test cleanup methods before all test methods</value>
  </data>
  <data name="MiKo_4102_Title" xml:space="preserve">
    <value>Test cleanup methods should be ordered before test methods.</value>
  </data>
</root>