<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="MiKo_0001_Description" xml:space="preserve">
    <value>Methods should be short to ease reading and maintenance (SRP, SLoA).</value>
  </data>
  <data name="MiKo_0001_MessageFormat" xml:space="preserve">
    <value>Too many LoC: {1,4} (allowed are max. {2})</value>
  </data>
  <data name="MiKo_0001_Title" xml:space="preserve">
    <value>Method is too big</value>
  </data>
  <data name="MiKo_0002_Description" xml:space="preserve">
    <value>Methods should be simple to ease maintenance (KISS).
Following code constructs increase the Cyclomatic Complexity (CC) by +1:
    if | while | for | foreach | case | continue | goto | &amp;&amp; | || | catch | catch when | ternary operator ?: | ?? | ?.</value>
  </data>
  <data name="MiKo_0002_MessageFormat" xml:space="preserve">
    <value>Too high CC: {1,4} (allowed are max. {2})</value>
  </data>
  <data name="MiKo_0002_Title" xml:space="preserve">
    <value>Method is too complex</value>
  </data>
  <data name="MiKo_0003_Description" xml:space="preserve">
    <value>Types should be limited in their size to ease reading and maintenance (SRP).</value>
  </data>
  <data name="MiKo_0003_MessageFormat" xml:space="preserve">
    <value>Too many LoC: {1,4} (allowed are max. {2})</value>
  </data>
  <data name="MiKo_0003_Title" xml:space="preserve">
    <value>Type is too big</value>
  </data>
  <data name="MiKo_0004_Description" xml:space="preserve">
    <value>To follow the SRP, methods should have as few parameters as possible.</value>
  </data>
  <data name="MiKo_0004_MessageFormat" xml:space="preserve">
    <value>Too many parameters: {1,4} (allowed are max. {2})</value>
  </data>
  <data name="MiKo_0004_Title" xml:space="preserve">
    <value>Method has too many parameters</value>
  </data>
  <data name="MiKo_0005_Description" xml:space="preserve">
    <value>Local functions should be short to ease reading and maintenance (SRP, SLoA).</value>
  </data>
  <data name="MiKo_0005_MessageFormat" xml:space="preserve">
    <value>Too many LoC: {1,4} (allowed are max. {2})</value>
  </data>
  <data name="MiKo_0005_Title" xml:space="preserve">
    <value>Local function is too big</value>
  </data>
  <data name="MiKo_0006_Description" xml:space="preserve">
    <value>Local functions should be simple to ease maintenance (KISS).
Following code constructs increase the Cyclomatic Complexity (CC) by +1:
    if | while | for | foreach | case | continue | goto | &amp;&amp; | || | catch | catch when | ternary operator ?: | ?? | ?.</value>
  </data>
  <data name="MiKo_0006_MessageFormat" xml:space="preserve">
    <value>Too high CC: {1,4} (allowed are max. {2})</value>
  </data>
  <data name="MiKo_0006_Title" xml:space="preserve">
    <value>Local function is too complex</value>
  </data>
  <data name="MiKo_0007_Description" xml:space="preserve">
    <value>To follow the SRP, local functions should have as few parameters as possible.</value>
  </data>
  <data name="MiKo_0007_MessageFormat" xml:space="preserve">
    <value>Too many parameters: {1,4} (allowed are max. {2})</value>
  </data>
  <data name="MiKo_0007_Title" xml:space="preserve">
    <value>Local function has too many parameters</value>
  </data>
  <data name="MiKo_1000_CodeFixTitle" xml:space="preserve">
    <value>Append suffix 'EventArgs'</value>
  </data>
  <data name="MiKo_1000_Description" xml:space="preserve">
    <value>Event argument types should follow the pattern that they inherit from 'System.EventArgs' and their names end with 'EventArgs'.</value>
  </data>
  <data name="MiKo_1000_MessageFormat" xml:space="preserve">
    <value>Name it '{1}' instead</value>
  </data>
  <data name="MiKo_1000_Title" xml:space="preserve">
    <value>'System.EventArgs' types should be suffixed with 'EventArgs'</value>
  </data>
  <data name="MiKo_1001_CodeFixTitle" xml:space="preserve">
    <value>Rename event argument</value>
  </data>
  <data name="MiKo_1001_Description" xml:space="preserve">
    <value>To ease maintenance, parameters that inherit from 'System.EventArgs' should be named 'e' .</value>
  </data>
  <data name="MiKo_1001_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/event</value>
  </data>
  <data name="MiKo_1001_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1001_Title" xml:space="preserve">
    <value>'System.EventArgs' parameters should be named 'e'</value>
  </data>
  <data name="MiKo_1002_CodeFixTitle" xml:space="preserve">
    <value>Rename event argument</value>
  </data>
  <data name="MiKo_1002_Description" xml:space="preserve">
    <value>To follow the .NET Framework Guidelines, parameters of event handlers should be named 'sender' and 'e'.</value>
  </data>
  <data name="MiKo_1002_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/event</value>
  </data>
  <data name="MiKo_1002_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1002_Title" xml:space="preserve">
    <value>Parameters should be named according the .NET Framework Guidelines for event handlers</value>
  </data>
  <data name="MiKo_1003_CodeFixTitle" xml:space="preserve">
    <value>Rename method according to event pattern</value>
  </data>
  <data name="MiKo_1003_Description" xml:space="preserve">
    <value>Event handlers should start with 'On', followed by the name of the event, to indicate that they handle events.</value>
  </data>
  <data name="MiKo_1003_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/csharp/event-pattern</value>
  </data>
  <data name="MiKo_1003_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1003_Title" xml:space="preserve">
    <value>Event handling method names should follow the .NET Framework Best Practices</value>
  </data>
  <data name="MiKo_1004_CodeFixTitle" xml:space="preserve">
    <value>Remove 'Event' suffix</value>
  </data>
  <data name="MiKo_1004_Description" xml:space="preserve">
    <value>'Event' as suffix in event names is noise and should be avoided.</value>
  </data>
  <data name="MiKo_1004_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1004_Title" xml:space="preserve">
    <value>Events should not contain term 'Event' in their names</value>
  </data>
  <data name="MiKo_1005_CodeFixTitle" xml:space="preserve">
    <value>Rename EventArgs variable</value>
  </data>
  <data name="MiKo_1005_Description" xml:space="preserve">
    <value>To ease maintenance, variables that are of type 'System.EventArgs' (or any inheritors) should be named 'e'.</value>
  </data>
  <data name="MiKo_1005_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1005_Title" xml:space="preserve">
    <value>'System.EventArgs' variables should be named properly</value>
  </data>
  <data name="MiKo_1006_Description" xml:space="preserve">
    <value>Events shall use 'EventHandler&lt;T&gt;' where 'T' is a class inherited from 'System.EventArgs' that is named after the event.
Example: A 'Loaded' event should use an 'EventHandler&lt;LoadedEventArgs&gt;'.</value>
  </data>
  <data name="MiKo_1006_MessageFormat" xml:space="preserve">
    <value>Use 'EventHandler&lt;{1}&gt;' instead</value>
  </data>
  <data name="MiKo_1006_Title" xml:space="preserve">
    <value>Events should use 'EventHandler&lt;T&gt;' with 'EventArgs' which are named after the event</value>
  </data>
  <data name="MiKo_1007_Description" xml:space="preserve">
    <value>Events and their event arguments belong together logically. Hence, both should be located in the same namespace.</value>
  </data>
  <data name="MiKo_1007_MessageFormat" xml:space="preserve">
    <value>Used '{1}' should be in namespace '{2}'</value>
  </data>
  <data name="MiKo_1007_Title" xml:space="preserve">
    <value>Events and their corresponding 'EventArgs' types should be located in the same namespace</value>
  </data>
  <data name="MiKo_1008_CodeFixTitle" xml:space="preserve">
    <value>Rename DependencyProperty event handler argument</value>
  </data>
  <data name="MiKo_1008_Description" xml:space="preserve">
    <value>To follow the .NET Framework Guidelines, parameters of DependencyProperty event handlers should be named 'd' and 'e'.</value>
  </data>
  <data name="MiKo_1008_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1008_Title" xml:space="preserve">
    <value>Parameters should be named according the .NET Framework Guidelines for DependencyProperty event handlers</value>
  </data>
  <data name="MiKo_1009_CodeFixTitle" xml:space="preserve">
    <value>Name event handler variable 'handler'</value>
  </data>
  <data name="MiKo_1009_Description" xml:space="preserve">
    <value>EventHandler variables should be named handler, to indicate that they handle events.</value>
  </data>
  <data name="MiKo_1009_MessageFormat" xml:space="preserve">
    <value>Name it 'handler'</value>
  </data>
  <data name="MiKo_1009_Title" xml:space="preserve">
    <value>'System.EventHandler' variables should be named properly</value>
  </data>
  <data name="MiKo_1010_CodeFixTitle" xml:space="preserve">
    <value>Remove 'Execute' from name</value>
  </data>
  <data name="MiKo_1010_Description" xml:space="preserve">
    <value>The purpose of methods is to execute code, so it's useless and repetitive to have 'CanExecute' or 'Execute' in their names.</value>
  </data>
  <data name="MiKo_1010_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1010_Title" xml:space="preserve">
    <value>Methods should not contain 'CanExecute' or 'Execute' in their names</value>
  </data>
  <data name="MiKo_1011_CodeFixTitle" xml:space="preserve">
    <value>Remove 'Do' from name</value>
  </data>
  <data name="MiKo_1011_Description" xml:space="preserve">
    <value>The purpose of methods is to execute code, so it's useless and repetitive to have 'Do' in their names.</value>
  </data>
  <data name="MiKo_1011_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1011_Title" xml:space="preserve">
    <value>Methods should not contain 'Do' in their names</value>
  </data>
  <data name="MiKo_1012_CodeFixTitle" xml:space="preserve">
    <value>Rename 'fire' to 'raise'</value>
  </data>
  <data name="MiKo_1012_Description" xml:space="preserve">
    <value>The term 'Fire' is a negative term. Employees get fired (or guns), but not events. Events get raised. So use 'Raise' instead.</value>
  </data>
  <data name="MiKo_1012_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1012_Title" xml:space="preserve">
    <value>Methods should be named 'Raise' instead of 'Fire'</value>
  </data>
  <data name="MiKo_1013_CodeFixTitle" xml:space="preserve">
    <value>Rename 'Notify' to 'On'</value>
  </data>
  <data name="MiKo_1013_Description" xml:space="preserve">
    <value>Many times, the term 'Notify' indicates that an event shall be raised. In such case, the prefix 'On' should be used instead.
Example: Instead of 'NotifyPropertyChanged' use 'OnPropertyChanged'.</value>
  </data>
  <data name="MiKo_1013_MessageFormat" xml:space="preserve">
    <value>Do not use term 'Notify'</value>
  </data>
  <data name="MiKo_1013_Title" xml:space="preserve">
    <value>Methods should not be named 'Notify' or 'OnNotify'</value>
  </data>
  <data name="MiKo_1014_CodeFixTitle" xml:space="preserve">
    <value>Rename 'Check'</value>
  </data>
  <data name="MiKo_1014_Description" xml:space="preserve">
    <value>The term 'Check' is ambiguous. If validation of parameters is meant, use something like 'Validate' or 'Verify'. If a check for a specific state is meant, use 'Is', 'Can' or 'Has' instead.</value>
  </data>
  <data name="MiKo_1014_MessageFormat" xml:space="preserve">
    <value>Do not use ambiguous term 'Check'</value>
  </data>
  <data name="MiKo_1014_Title" xml:space="preserve">
    <value>Methods should not be named with ambiguous 'Check'</value>
  </data>
  <data name="MiKo_1015_CodeFixTitle" xml:space="preserve">
    <value>Rename 'Init' to 'Initialize'</value>
  </data>
  <data name="MiKo_1015_Description" xml:space="preserve">
    <value>The term 'Init' is a lazy abbreviation and should not be used. 'Initialize' should be used instead.</value>
  </data>
  <data name="MiKo_1015_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1015_Title" xml:space="preserve">
    <value>Methods should be named 'Initialize' instead of 'Init'</value>
  </data>
  <data name="MiKo_1016_CodeFixTitle" xml:space="preserve">
    <value>Rename factory method</value>
  </data>
  <data name="MiKo_1016_Description" xml:space="preserve">
    <value>The method belongs to a factory and therefore its name should be started with 'Create'.</value>
  </data>
  <data name="MiKo_1016_MessageFormat" xml:space="preserve">
    <value>Start name with 'Create'</value>
  </data>
  <data name="MiKo_1016_Title" xml:space="preserve">
    <value>Factory methods should be named 'Create'</value>
  </data>
  <data name="MiKo_1017_CodeFixTitle" xml:space="preserve">
    <value>Remove prefix from method</value>
  </data>
  <data name="MiKo_1017_Description" xml:space="preserve">
    <value>Methods should not be prefixed with 'Get' or 'Set' if followed by 'Is', 'Can' or 'Has'. That 'Get' or 'Set' is just additional noise and should be avoided.</value>
  </data>
  <data name="MiKo_1017_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1017_Title" xml:space="preserve">
    <value>Methods should not be prefixed with 'Get' or 'Set' if followed by 'Is', 'Can' or 'Has'</value>
  </data>
  <data name="MiKo_1018_CodeFixTitle" xml:space="preserve">
    <value>Change noun to verb</value>
  </data>
  <data name="MiKo_1018_Description" xml:space="preserve">
    <value>Methods should not be suffixed with a noun form of a verb if the verb would fit perfectly as method name.</value>
  </data>
  <data name="MiKo_1018_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1018_Title" xml:space="preserve">
    <value>Methods should not be suffixed with noun of a verb</value>
  </data>
  <data name="MiKo_1019_CodeFixTitle" xml:space="preserve">
    <value>Rename 'Clear' and 'Remove'</value>
  </data>
  <data name="MiKo_1019_Description" xml:space="preserve">
    <value>Methods that are named 'Remove' and have no parameters should be named 'Clear' instead as they do not remove parameters.
Methods that are named 'Clear' and have parameters should be named 'Remove' instead as they do not clear the item.</value>
  </data>
  <data name="MiKo_1019_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1019_Title" xml:space="preserve">
    <value>'Clear' and 'Remove' methods should be named based on their number of parameters</value>
  </data>
  <data name="MiKo_1020_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1020_MessageFormat" xml:space="preserve">
    <value>Type name exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1020_Title" xml:space="preserve">
    <value>Type names should be limited in length</value>
  </data>
  <data name="MiKo_1021_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1021_MessageFormat" xml:space="preserve">
    <value>Method name exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1021_Title" xml:space="preserve">
    <value>Method names should be limited in length</value>
  </data>
  <data name="MiKo_1022_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1022_MessageFormat" xml:space="preserve">
    <value>Parameter name exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1022_Title" xml:space="preserve">
    <value>Parameter names should be limited in length</value>
  </data>
  <data name="MiKo_1023_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1023_MessageFormat" xml:space="preserve">
    <value>Field name exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1023_Title" xml:space="preserve">
    <value>Field names should be limited in length</value>
  </data>
  <data name="MiKo_1024_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1024_MessageFormat" xml:space="preserve">
    <value>Property name exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1024_Title" xml:space="preserve">
    <value>Property names should be limited in length</value>
  </data>
  <data name="MiKo_1025_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1025_MessageFormat" xml:space="preserve">
    <value>Event name exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1025_Title" xml:space="preserve">
    <value>Event names should be limited in length</value>
  </data>
  <data name="MiKo_1026_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1026_MessageFormat" xml:space="preserve">
    <value>Variable name exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1026_Title" xml:space="preserve">
    <value>Variable names should be limited in length</value>
  </data>
  <data name="MiKo_1027_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1027_MessageFormat" xml:space="preserve">
    <value>Variable name in loop exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1027_Title" xml:space="preserve">
    <value>Variable names in loops should be limited in length</value>
  </data>
  <data name="MiKo_1028_Description" xml:space="preserve">
    <value>Names that have a lot of characters are hard to read when being used. This makes writing code and doing code reviews much harder.</value>
  </data>
  <data name="MiKo_1028_MessageFormat" xml:space="preserve">
    <value>Local function name exceeds limit of {2} chars by {1}</value>
  </data>
  <data name="MiKo_1028_Title" xml:space="preserve">
    <value>Local function names should be limited in length</value>
  </data>
  <data name="MiKo_1030_CodeFixTitle" xml:space="preserve">
    <value>Remove base type indicator</value>
  </data>
  <data name="MiKo_1030_Description" xml:space="preserve">
    <value>Indicating that a type is a base type by putting 'Abstract' or 'Base' in its name does not make sense. Every interface or class that is not sealed can act as a base class.</value>
  </data>
  <data name="MiKo_1030_MessageFormat" xml:space="preserve">
    <value>Remove '{1}' from name</value>
  </data>
  <data name="MiKo_1030_Title" xml:space="preserve">
    <value>Types should not have an 'Abstract' or 'Base' marker to indicate that they are base types</value>
  </data>
  <data name="MiKo_1031_CodeFixTitle" xml:space="preserve">
    <value>Remove 'Model' indicator</value>
  </data>
  <data name="MiKo_1031_Description" xml:space="preserve">
    <value>Indicating that a type is an entity by using 'Model' as its suffix does not make sense. Entities should not be suffixed at all. (eg. 'User' instead of 'UserModel')</value>
  </data>
  <data name="MiKo_1031_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1031_Title" xml:space="preserve">
    <value>Entity types should not use a 'Model' suffix</value>
  </data>
  <data name="MiKo_1032_CodeFixTitle" xml:space="preserve">
    <value>Remove 'Model' indicator</value>
  </data>
  <data name="MiKo_1032_Description" xml:space="preserve">
    <value>Indicating that a method deals with an entity by using 'Model' in its name does not make sense.</value>
  </data>
  <data name="MiKo_1032_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1032_Title" xml:space="preserve">
    <value>Methods dealing with entities should not use a 'Model' as marker</value>
  </data>
  <data name="MiKo_1033_CodeFixTitle" xml:space="preserve">
    <value>Remove 'Model' indicator</value>
  </data>
  <data name="MiKo_1033_Description" xml:space="preserve">
    <value>Indicating that a parameter is an entity by using 'Model' as its suffix does not make sense. Entities should not be suffixed at all. (eg. 'user' instead of 'userModel')</value>
  </data>
  <data name="MiKo_1033_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1033_Title" xml:space="preserve">
    <value>Parameters representing entities should not use a 'Model' suffix</value>
  </data>
  <data name="MiKo_1034_CodeFixTitle" xml:space="preserve">
    <value>Remove 'Model' indicator</value>
  </data>
  <data name="MiKo_1034_Description" xml:space="preserve">
    <value>Indicating that a field is an entity by using 'Model' as its suffix does not make sense. Entities should not be suffixed at all. (eg. 'user' instead of 'userModel')</value>
  </data>
  <data name="MiKo_1034_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1034_Title" xml:space="preserve">
    <value>Fields representing entities should not use a 'Model' suffix</value>
  </data>
  <data name="MiKo_1035_CodeFixTitle" xml:space="preserve">
    <value>Remove 'Model' indicator</value>
  </data>
  <data name="MiKo_1035_Description" xml:space="preserve">
    <value>Indicating that a property deals with an entity by using 'Model' in its name does not make sense.</value>
  </data>
  <data name="MiKo_1035_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1035_Title" xml:space="preserve">
    <value>Properties dealing with entities should not use a 'Model' marker</value>
  </data>
  <data name="MiKo_1036_CodeFixTitle" xml:space="preserve">
    <value>Remove 'Model' indicator</value>
  </data>
  <data name="MiKo_1036_Description" xml:space="preserve">
    <value>Indicating that an event deals with an entity by using 'Model' in its name does not make sense.</value>
  </data>
  <data name="MiKo_1036_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1036_Title" xml:space="preserve">
    <value>Events dealing with entities should not use a 'Model' marker</value>
  </data>
  <data name="MiKo_1037_CodeFixTitle" xml:space="preserve">
    <value>Remove 'Enum' suffix</value>
  </data>
  <data name="MiKo_1037_Description" xml:space="preserve">
    <value>Indicating that a type is an Enum by using 'Enum' as its suffix does not make sense.</value>
  </data>
  <data name="MiKo_1037_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1037_Title" xml:space="preserve">
    <value>Types should not be suffixed with 'Enum'</value>
  </data>
  <data name="MiKo_1038_CodeFixTitle" xml:space="preserve">
    <value>Suffix type with 'Extensions'</value>
  </data>
  <data name="MiKo_1038_Description" xml:space="preserve">
    <value>To ease maintenance, the names of classes that contain extension methods should end with the same suffix.</value>
  </data>
  <data name="MiKo_1038_MessageFormat" xml:space="preserve">
    <value>End name with '{1}'</value>
  </data>
  <data name="MiKo_1038_Title" xml:space="preserve">
    <value>Classes that contain extension methods should end with same suffix</value>
  </data>
  <data name="MiKo_1039_CodeFixTitle" xml:space="preserve">
    <value>Rename 'this' argument</value>
  </data>
  <data name="MiKo_1039_Description" xml:space="preserve">
    <value>To ease maintenance, the 'this' parameter of extension methods should have a default name.</value>
  </data>
  <data name="MiKo_1039_MessageFormat" xml:space="preserve">
    <value>Name it {1}</value>
  </data>
  <data name="MiKo_1039_Title" xml:space="preserve">
    <value>The 'this' parameter of extension methods should have a default name</value>
  </data>
  <data name="MiKo_1040_Description" xml:space="preserve">
    <value>Suffixes on parameter names (such as 'List') are noise and should be avoided.</value>
  </data>
  <data name="MiKo_1040_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1040_Title" xml:space="preserve">
    <value>Parameters should not be suffixed with implementation details</value>
  </data>
  <data name="MiKo_1041_Description" xml:space="preserve">
    <value>Suffixes on field names (such as 'List') are noise and should be avoided.</value>
  </data>
  <data name="MiKo_1041_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1041_Title" xml:space="preserve">
    <value>Fields should not be suffixed with implementation details</value>
  </data>
  <data name="MiKo_1042_CodeFixTitle" xml:space="preserve">
    <value>Name it 'cancellationToken'</value>
  </data>
  <data name="MiKo_1042_Description" xml:space="preserve">
    <value>To ease maintenance, and being consistent with the .NET Framework classes, 'CancellationToken' parameters should have a very specific name.</value>
  </data>
  <data name="MiKo_1042_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1042_Title" xml:space="preserve">
    <value>'CancellationToken' parameters should have specific name</value>
  </data>
  <data name="MiKo_1043_CodeFixTitle" xml:space="preserve">
    <value>Name it 'token'</value>
  </data>
  <data name="MiKo_1043_Description" xml:space="preserve">
    <value>To ease maintenance, 'CancellationToken' variables should have a very specific name.</value>
  </data>
  <data name="MiKo_1043_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1043_Title" xml:space="preserve">
    <value>'CancellationToken' variables should have specific name</value>
  </data>
  <data name="MiKo_1044_CodeFixTitle" xml:space="preserve">
    <value>Append 'Command' suffix</value>
  </data>
  <data name="MiKo_1044_Description" xml:space="preserve">
    <value>To ease maintenance, add the suffix 'Command'.</value>
  </data>
  <data name="MiKo_1044_MessageFormat" xml:space="preserve">
    <value>Add '{1}' as suffix</value>
  </data>
  <data name="MiKo_1044_Title" xml:space="preserve">
    <value>Commands should be suffixed with 'Command'</value>
  </data>
  <data name="MiKo_1045_CodeFixTitle" xml:space="preserve">
    <value>Remove 'Command' suffix</value>
  </data>
  <data name="MiKo_1045_Description" xml:space="preserve">
    <value>To ease maintenance, remove the suffix 'Command' as the method itself is invoked by a command.</value>
  </data>
  <data name="MiKo_1045_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1045_Title" xml:space="preserve">
    <value>Methods that are invoked by commands should not be suffixed with 'Command'</value>
  </data>
  <data name="MiKo_1046_CodeFixTitle" xml:space="preserve">
    <value>Append 'Async' suffix</value>
  </data>
  <data name="MiKo_1046_Description" xml:space="preserve">
    <value>To ease maintenance, methods that follow the Task-based Asynchronous Pattern (TAP) should be suffixed with 'Async'.</value>
  </data>
  <data name="MiKo_1046_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap</value>
  </data>
  <data name="MiKo_1046_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1046_Title" xml:space="preserve">
    <value>Asynchronous methods should follow the Task-based Asynchronous Pattern (TAP)</value>
  </data>
  <data name="MiKo_1047_CodeFixTitle" xml:space="preserve">
    <value>Remove 'Async' suffix</value>
  </data>
  <data name="MiKo_1047_Description" xml:space="preserve">
    <value>To ease maintenance, methods that do not follow the Task-based Asynchronous Pattern (TAP) should not be suffixed with 'Async' as that would indicate that they would follow the pattern.</value>
  </data>
  <data name="MiKo_1047_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap</value>
  </data>
  <data name="MiKo_1047_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1047_Title" xml:space="preserve">
    <value>Methods not following the Task-based Asynchronous Pattern (TAP) should not lie about being asynchronous</value>
  </data>
  <data name="MiKo_1048_CodeFixTitle" xml:space="preserve">
    <value>Append 'Converter' suffix</value>
  </data>
  <data name="MiKo_1048_Description" xml:space="preserve">
    <value>Classes that are value converters should end with a specific suffix.</value>
  </data>
  <data name="MiKo_1048_MessageFormat" xml:space="preserve">
    <value>End name with '{1}'</value>
  </data>
  <data name="MiKo_1048_Title" xml:space="preserve">
    <value>To ease maintenance, the names of classes that are value converters should end with the same suffix</value>
  </data>
  <data name="MiKo_1049_CodeFixTitle" xml:space="preserve">
    <value>Replace requirement term</value>
  </data>
  <data name="MiKo_1049_Description" xml:space="preserve">
    <value>Requirement terms such as 'Must', 'Need', 'Shall', 'Should', 'Will' or 'Would' within a name are not explicit enough. Instead, use a positive verb or an adjective like 'Is', 'Has', 'Can', etc.</value>
  </data>
  <data name="MiKo_1049_MessageFormat" xml:space="preserve">
    <value>Do not use '{1}' in name</value>
  </data>
  <data name="MiKo_1049_Title" xml:space="preserve">
    <value>Do not use requirement terms such as 'Shall', 'Should', 'Must' or 'Need' for names</value>
  </data>
  <data name="MiKo_1050_CodeFixTitle" xml:space="preserve">
    <value>Rename return value</value>
  </data>
  <data name="MiKo_1050_Description" xml:space="preserve">
    <value>Variables for return values should describe what data they contain and not what they technical are.
So they should have better names than e.g. 'ret', 'retVal' or 'returnValue'.</value>
  </data>
  <data name="MiKo_1050_MessageFormat" xml:space="preserve">
    <value>Use a more descriptive name than '{1}'</value>
  </data>
  <data name="MiKo_1050_Title" xml:space="preserve">
    <value>Return values should have descriptive names</value>
  </data>
  <data name="MiKo_1051_CodeFixTitle" xml:space="preserve">
    <value>Name it 'callback'</value>
  </data>
  <data name="MiKo_1051_Description" xml:space="preserve">
    <value>Suffixing delegate parameters with their type is repetitive and provides no value. A more meaningful name (such as 'callback', 'filter' or 'map') provides much more context.</value>
  </data>
  <data name="MiKo_1051_MessageFormat" xml:space="preserve">
    <value>Use a better matching name instead</value>
  </data>
  <data name="MiKo_1051_Title" xml:space="preserve">
    <value>Do not suffix parameters with delegate types</value>
  </data>
  <data name="MiKo_1052_CodeFixTitle" xml:space="preserve">
    <value>Name it 'callback'</value>
  </data>
  <data name="MiKo_1052_Description" xml:space="preserve">
    <value>Suffixing delegate variables with their type is repetitive and provides no value. A more meaningful name (such as 'callback', 'filter' or 'map') provides much more context.</value>
  </data>
  <data name="MiKo_1052_MessageFormat" xml:space="preserve">
    <value>Use a better matching name instead</value>
  </data>
  <data name="MiKo_1052_Title" xml:space="preserve">
    <value>Do not suffix variables with delegate types</value>
  </data>
  <data name="MiKo_1053_CodeFixTitle" xml:space="preserve">
    <value>Rename delegate field</value>
  </data>
  <data name="MiKo_1053_Description" xml:space="preserve">
    <value>Suffixing delegate fields with their type is repetitive and provides no value. A more meaningful name (such as 'callback', 'filter' or 'map') provides much more context.</value>
  </data>
  <data name="MiKo_1053_MessageFormat" xml:space="preserve">
    <value>Use a better matching name instead</value>
  </data>
  <data name="MiKo_1053_Title" xml:space="preserve">
    <value>Do not suffix fields with delegate types</value>
  </data>
  <data name="MiKo_1054_CodeFixTitle" xml:space="preserve">
    <value>Remove 'Utility' marker suffix</value>
  </data>
  <data name="MiKo_1054_Description" xml:space="preserve">
    <value>Terms such as 'helper' or 'utility' are too generic and meaningless.
Types that are named so do not follow the Single Responsibility Principle (SRP); instead they have a scope that is much too broad.</value>
  </data>
  <data name="MiKo_1054_MessageFormat" xml:space="preserve">
    <value>Remove '{1}' from name</value>
  </data>
  <data name="MiKo_1054_Title" xml:space="preserve">
    <value>Do not name types 'Helper' or 'Utility'</value>
  </data>
  <data name="MiKo_1055_CodeFixTitle" xml:space="preserve">
    <value>Rename dependency property</value>
  </data>
  <data name="MiKo_1055_Description" xml:space="preserve">
    <value>To indicate that fields are the containers for specific dependency properties, those fields should be suffixed with 'Property' (similar as in the .NET Framework).</value>
  </data>
  <data name="MiKo_1055_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/how-to-implement-a-dependency-property</value>
  </data>
  <data name="MiKo_1055_MessageFormat" xml:space="preserve">
    <value>Name it '{1}' instead</value>
  </data>
  <data name="MiKo_1055_Title" xml:space="preserve">
    <value>Dependency properties should be suffixed with 'Property' (as in the .NET Framework)</value>
  </data>
  <data name="MiKo_1056_Description" xml:space="preserve">
    <value>To indicate that fields are the containers for specific dependency properties, those fields should be prefixed with the name of the property (similar as in the .NET Framework).</value>
  </data>
  <data name="MiKo_1056_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/how-to-implement-a-dependency-property</value>
  </data>
  <data name="MiKo_1056_MessageFormat" xml:space="preserve">
    <value>Name it {1} instead</value>
  </data>
  <data name="MiKo_1056_Title" xml:space="preserve">
    <value>Dependency properties should be prefixed with property names (as in the .NET Framework)</value>
  </data>
  <data name="MiKo_1057_CodeFixTitle" xml:space="preserve">
    <value>Rename dependency property key</value>
  </data>
  <data name="MiKo_1057_Description" xml:space="preserve">
    <value>To indicate that fields are the keys for specific dependency properties, those fields should be suffixed with 'Key' (similar as in the .NET Framework).</value>
  </data>
  <data name="MiKo_1057_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/api/system.windows.dependencypropertykey</value>
  </data>
  <data name="MiKo_1057_MessageFormat" xml:space="preserve">
    <value>Name it '{1}' instead</value>
  </data>
  <data name="MiKo_1057_Title" xml:space="preserve">
    <value>Dependency property keys should be suffixed with 'Key' (as in the .NET Framework)</value>
  </data>
  <data name="MiKo_1058_Description" xml:space="preserve">
    <value>To indicate that fields are the keys for specific dependency properties, those fields should be prefixed with the name of the property (similar as in the .NET Framework).</value>
  </data>
  <data name="MiKo_1058_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/api/system.windows.dependencypropertykey</value>
  </data>
  <data name="MiKo_1058_MessageFormat" xml:space="preserve">
    <value>Name it {1} instead</value>
  </data>
  <data name="MiKo_1058_Title" xml:space="preserve">
    <value>Dependency property keys should be prefixed with property names (as in the .NET Framework)</value>
  </data>
  <data name="MiKo_1059_CodeFixTitle" xml:space="preserve">
    <value>Remove 'Impl' marker suffix</value>
  </data>
  <data name="MiKo_1059_Description" xml:space="preserve">
    <value>Terms such as 'Impl' or 'Implementation' are meaningless and provide no benefit.
Types that are named so should be better named directly after the interface they implement, but without any 'Impl' marker.</value>
  </data>
  <data name="MiKo_1059_MessageFormat" xml:space="preserve">
    <value>Remove '{1}' from name</value>
  </data>
  <data name="MiKo_1059_Title" xml:space="preserve">
    <value>Do not name types 'Impl' or 'Implementation'</value>
  </data>
  <data name="MiKo_1060_Description" xml:space="preserve">
    <value>Sometimes, developers try to report that an entity was not found.

For example, a repository is requested to return an entity 'Xyz' (e.g. via method 'GetXyz'). In case that such entity does not exist, they either return an error code (such as null) or they throw an exception.

The name of the exception is then sometimes 'GetXyzFailedException' which is not that clear (why did it fail?). A better name would be 'XyzNotFoundException' to indicate that 'Xyz' was not found.

The same applies for 'XyzMissingException'. It is probably not missing (which means it should be actually there but is not); it is just not there and therefore cannot be found. So, 'XyzNotFoundException' would be a better, more precise name as well.</value>
  </data>
  <data name="MiKo_1060_MessageFormat" xml:space="preserve">
    <value>Consider to name it '{0}'</value>
  </data>
  <data name="MiKo_1060_Title" xml:space="preserve">
    <value>Use '&lt;Entity&gt;NotFound' instead of 'Get&lt;Entity&gt;Failed' or '&lt;Entity&gt;Missing'</value>
  </data>
  <data name="MiKo_1061_CodeFixTitle" xml:space="preserve">
    <value>Rename out parameter</value>
  </data>
  <data name="MiKo_1061_Description" xml:space="preserve">
    <value>If a 'TryXyz' method has an [out] parameter, that [out] parameter shall be named specifically because it is the actual result of the method. The method's return value only exists to indicate a success or failure of the operation.

- For a 'Try' method, that parameter shall be named 'result'.
- For a 'TryGet' method, that parameter shall be named after the name of the method without the 'TryGet' prefix.
   Example: For the 'TryGetMyValue' method the parameter shall be named 'myValue'.</value>
  </data>
  <data name="MiKo_1061_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1061_Title" xml:space="preserve">
    <value>The name of 'Try' method's [out] parameter should be specific</value>
  </data>
  <data name="MiKo_1062_Description" xml:space="preserve">
    <value>Detection methods (properties or fields) such as 'Can', 'Has' or 'Contains' should consist only of a few words, such as 'HasConnection' or 'ContainsKey'.
If they consist of more than those few words, these methods (properties or fields) are probably placed at the wrong place and violate the SRP.</value>
  </data>
  <data name="MiKo_1062_MessageFormat" xml:space="preserve">
    <value>Avoid name with more than {1} words</value>
  </data>
  <data name="MiKo_1062_Title" xml:space="preserve">
    <value>'Can/Has/Contains' methods, properties or fields shall consist of only a few words</value>
  </data>
  <data name="MiKo_1063_Description" xml:space="preserve">
    <value>Using abbreviations in names is bad practice.
It makes it hard for every developer that is new to the code base to understand what is meant by the code.
In addition, they distract the reader's attention as they have to translate the meaning each time.</value>
  </data>
  <data name="MiKo_1063_MessageFormat" xml:space="preserve">
    <value>Use '{2}' instead of abbreviation '{1}'</value>
  </data>
  <data name="MiKo_1063_Title" xml:space="preserve">
    <value>Do not use abbreviations in names</value>
  </data>
  <data name="MiKo_1064_Description" xml:space="preserve">
    <value>To ease maintenance, parameter names should be based on the parameter’s meaning rather than the parameter’s type.</value>
  </data>
  <data name="MiKo_1064_MessageFormat" xml:space="preserve">
    <value>Name parameter based on its meaning instead of its type</value>
  </data>
  <data name="MiKo_1064_Title" xml:space="preserve">
    <value>Parameter names reflect their meaning and not their type</value>
  </data>
  <data name="MiKo_1065_CodeFixTitle" xml:space="preserve">
    <value>Rename operator parameter</value>
  </data>
  <data name="MiKo_1065_Description" xml:space="preserve">
    <value>Parameters of operator overloads should have default names if there is no meaning to the parameters.
For binary operator overloads use the names 'left' and 'right', for unary operator overloads use the name 'value'.</value>
  </data>
  <data name="MiKo_1065_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-parameters</value>
  </data>
  <data name="MiKo_1065_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1065_Title" xml:space="preserve">
    <value>Parameter names do not follow .NET Framework Guidelines for operator overloads</value>
  </data>
  <data name="MiKo_1067_CodeFixTitle" xml:space="preserve">
    <value>Remove 'Perform' from name</value>
  </data>
  <data name="MiKo_1067_Description" xml:space="preserve">
    <value>The purpose of methods is to execute code, so it's useless and repetitive to have 'Perform' in their names.</value>
  </data>
  <data name="MiKo_1067_MessageFormat" xml:space="preserve">
    <value>Remove 'Perform' from name</value>
  </data>
  <data name="MiKo_1067_Title" xml:space="preserve">
    <value>Methods should not contain 'Perform' in their names</value>
  </data>
  <data name="MiKo_1068_Description" xml:space="preserve">
    <value>Workflows are a high-level construct and encapsulate functionality that belongs into the business layer.
Hence, their methods should be named 'CanRun' or 'Run' (similar to commands where they are named 'CanExecute' and 'Execute').</value>
  </data>
  <data name="MiKo_1068_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1068_Title" xml:space="preserve">
    <value>Workflow methods should be named 'CanRun' or 'Run'</value>
  </data>
  <data name="MiKo_1069_Description" xml:space="preserve">
    <value>To ease maintenance, property names should be based on the property’s meaning rather than its type.</value>
  </data>
  <data name="MiKo_1069_MessageFormat" xml:space="preserve">
    <value>Name property based on its meaning instead of its type</value>
  </data>
  <data name="MiKo_1069_Title" xml:space="preserve">
    <value>Property names reflect their meaning and not their type</value>
  </data>
  <data name="MiKo_1070_CodeFixTitle" xml:space="preserve">
    <value>Rename variable into plural</value>
  </data>
  <data name="MiKo_1070_Description" xml:space="preserve">
    <value>Local variables for collections (that is any which is an 'IEnumerable') should have names in plural form. Their names should describe the contents of the collection; and not the collection itself.</value>
  </data>
  <data name="MiKo_1070_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1070_Title" xml:space="preserve">
    <value>Local collection variables shall use plural name</value>
  </data>
  <data name="MiKo_1071_Description" xml:space="preserve">
    <value>Boolean variables define some state. So they should be named as statements and not as questions.
That easies reading, as most likely, boolean variables are used in if/else or switch statements.

Example:
   'isDeviceOnline' is a question.
   'deviceIsOnline' instead is a statement.

   'if (isDeviceOnline) DoSomething();' is harder to read
   'if (deviceIsOnline) DoSomething();' is more fluent to read.</value>
  </data>
  <data name="MiKo_1071_MessageFormat" xml:space="preserve">
    <value>Formulate question as statement</value>
  </data>
  <data name="MiKo_1071_Title" xml:space="preserve">
    <value>Local boolean variables should be named as statements and not as questions</value>
  </data>
  <data name="MiKo_1072_Description" xml:space="preserve">
    <value>Boolean properties or methods define some state. So they should be named as statements and not as questions.
That easies reading, as most likely, boolean properties or methods are used in if/else or switch statements.

Example:
   'IsDeviceOnline' is a question.
   'DeviceIsOnline' instead is a statement.

   'if (IsDeviceOnline) DoSomething();' is harder to read
   'if (DeviceIsOnline) DoSomething();' is more fluent to read.</value>
  </data>
  <data name="MiKo_1072_MessageFormat" xml:space="preserve">
    <value>Formulate question as statement</value>
  </data>
  <data name="MiKo_1072_Title" xml:space="preserve">
    <value>Boolean properties or methods should be named as statements and not as questions</value>
  </data>
  <data name="MiKo_1073_Description" xml:space="preserve">
    <value>Boolean fields define some state. So they should be named as statements and not as questions.
That easies reading, as most likely, boolean fields are used in if/else or switch statements.

Example:
   'IsDeviceOnline' is a question.
   'DeviceIsOnline' instead is a statement.

   'if (IsDeviceOnline) DoSomething();' is harder to read
   'if (DeviceIsOnline) DoSomething();' is more fluent to read.</value>
  </data>
  <data name="MiKo_1073_MessageFormat" xml:space="preserve">
    <value>Formulate question as statement</value>
  </data>
  <data name="MiKo_1073_Title" xml:space="preserve">
    <value>Boolean fields should be named as statements and not as questions</value>
  </data>
  <data name="MiKo_1080_Description" xml:space="preserve">
    <value>It is much easier to read a number inside a name if it is written as number and not its spelling (e.g. 'issue42' in contrast to 'issueFortyTwo').</value>
  </data>
  <data name="MiKo_1080_MessageFormat" xml:space="preserve">
    <value>Use number instead of spelling</value>
  </data>
  <data name="MiKo_1080_Title" xml:space="preserve">
    <value>Names should contain numbers instead of their spellings</value>
  </data>
  <data name="MiKo_1081_CodeFixTitle" xml:space="preserve">
    <value>Remove number</value>
  </data>
  <data name="MiKo_1081_Description" xml:space="preserve">
    <value>Suffixing methods with a number makes it hard for the users of the methods to use them as it is unclear which one is the correct or whether they have to be used in conjunction. So instead of using a number suffix methods should have a proper descriptive name.</value>
  </data>
  <data name="MiKo_1081_MessageFormat" xml:space="preserve">
    <value>Do not use a number as suffix</value>
  </data>
  <data name="MiKo_1081_Title" xml:space="preserve">
    <value>Methods should not be suffixed with a number</value>
  </data>
  <data name="MiKo_1082_CodeFixTitle" xml:space="preserve">
    <value>Remove number</value>
  </data>
  <data name="MiKo_1082_Description" xml:space="preserve">
    <value>Suffixing properties with a number (especially if the type they return have a number as well) makes them unnecessary difficult to read. Most times the number can simply be avoided, which in turn makes them easier to read (and they are to the point).</value>
  </data>
  <data name="MiKo_1082_MessageFormat" xml:space="preserve">
    <value>Do not use a number as suffix</value>
  </data>
  <data name="MiKo_1082_Title" xml:space="preserve">
    <value>Properties should not be suffixed with a number if their types have number suffixes</value>
  </data>
  <data name="MiKo_1083_CodeFixTitle" xml:space="preserve">
    <value>Remove number</value>
  </data>
  <data name="MiKo_1083_Description" xml:space="preserve">
    <value>Suffixing fields with a number (especially if their types have a number as well) makes them unnecessary difficult to read. Most times the number can simply be avoided, which in turn makes them easier to read (and they are to the point).</value>
  </data>
  <data name="MiKo_1083_MessageFormat" xml:space="preserve">
    <value>Do not use a number as suffix</value>
  </data>
  <data name="MiKo_1083_Title" xml:space="preserve">
    <value>Fields should not be suffixed with a number if their types have number suffixes</value>
  </data>
  <data name="MiKo_1084_CodeFixTitle" xml:space="preserve">
    <value>Remove number</value>
  </data>
  <data name="MiKo_1084_Description" xml:space="preserve">
    <value>Suffixing variables with a number (especially if their types have a number as well) makes them unnecessary difficult to read. Most times the number can simply be avoided, which in turn makes them easier to read (and they are to the point).</value>
  </data>
  <data name="MiKo_1084_MessageFormat" xml:space="preserve">
    <value>Do not use a number as suffix</value>
  </data>
  <data name="MiKo_1084_Title" xml:space="preserve">
    <value>Variables should not be suffixed with a number if their types have number suffixes</value>
  </data>
  <data name="MiKo_1085_CodeFixTitle" xml:space="preserve">
    <value>Remove number</value>
  </data>
  <data name="MiKo_1085_Description" xml:space="preserve">
    <value>Suffixing parameters with number provides no benefit. So instead of using a number suffix parameters should have a proper descriptive name.</value>
  </data>
  <data name="MiKo_1085_MessageFormat" xml:space="preserve">
    <value>Do not use a number as suffix</value>
  </data>
  <data name="MiKo_1085_Title" xml:space="preserve">
    <value>Parameters should not be suffixed with a number</value>
  </data>
  <data name="MiKo_1086_Description" xml:space="preserve">
    <value>Using numbers in method names such 'Send2You' or 'Do4You' is slang and should be avoided. Instead, the correct words 'To' or 'For' should be used.</value>
  </data>
  <data name="MiKo_1086_MessageFormat" xml:space="preserve">
    <value>Do not use a number as slang</value>
  </data>
  <data name="MiKo_1086_Title" xml:space="preserve">
    <value>Methods should not be named using numbers as slang</value>
  </data>
  <data name="MiKo_1090_CodeFixTitle" xml:space="preserve">
    <value>Rename parameter</value>
  </data>
  <data name="MiKo_1090_Description" xml:space="preserve">
    <value>Instead of suffixing a parameter with a specific type (such as xyzComparer, xyzView, or xyzItem), the parameter should be named so (comparer, view or item).

The reason is that the type already states what the parameter is - so its name should not have that additional, redundant information.</value>
  </data>
  <data name="MiKo_1090_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1090_Title" xml:space="preserve">
    <value>Parameters should not be suffixed with specific types</value>
  </data>
  <data name="MiKo_1091_CodeFixTitle" xml:space="preserve">
    <value>Remove variable suffix</value>
  </data>
  <data name="MiKo_1091_Description" xml:space="preserve">
    <value>Instead of suffixing a variable with a specific type (such as xyzComparer, xyzView, or xyzItem), the variable should be named so (comparer, view or item).

The reason is that the type already states what the variable is - so its name should not have that additional, redundant information.</value>
  </data>
  <data name="MiKo_1091_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1091_Title" xml:space="preserve">
    <value>Variables should not be suffixed with specific types</value>
  </data>
  <data name="MiKo_1092_CodeFixTitle" xml:space="preserve">
    <value>Remove suffix</value>
  </data>
  <data name="MiKo_1092_Description" xml:space="preserve">
    <value>Instead of suffixing an 'ability' type with redundant information (such as 'ComparableItem'), the redundant information should be left out of the name of the type (such as 'Comparable').</value>
  </data>
  <data name="MiKo_1092_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1092_Title" xml:space="preserve">
    <value>'Ability' Types should not be suffixed with redundant information</value>
  </data>
  <data name="MiKo_1093_CodeFixTitle" xml:space="preserve">
    <value>Remove suffix 'Object' or 'Struct'</value>
  </data>
  <data name="MiKo_1093_Description" xml:space="preserve">
    <value>Identifiers should not have the term 'Object' or 'Struct' as suffix. Many times, a mcuh better name can be given that avoids the usage of the term 'Object' or 'Struct' at all (such as 'Identifier' instead of 'IdentificationObject').</value>
  </data>
  <data name="MiKo_1093_MessageFormat" xml:space="preserve">
    <value>Do not use suffix '{1}'</value>
  </data>
  <data name="MiKo_1093_Title" xml:space="preserve">
    <value>Do not use the suffix 'Object' or 'Struct'</value>
  </data>
  <data name="MiKo_1094_Description" xml:space="preserve">
    <value>Types should use suffixes that identify them as types and are in active case, they should not use suffixes that are passive and would belong into names of namespaces.
For example, types should not be suffixed with 'Management' or 'Handling'. Instead, they should be suffixed with the more active terms 'Manager' or 'Handler'.</value>
  </data>
  <data name="MiKo_1094_MessageFormat" xml:space="preserve">
    <value>Name it '{1}' instead</value>
  </data>
  <data name="MiKo_1094_Title" xml:space="preserve">
    <value>Do not suffix types with passive namespace names</value>
  </data>
  <data name="MiKo_1095_Description" xml:space="preserve">
    <value>Although the terms 'Delete' and 'Remove' are defined quite similarly, there is a main difference between both:
- 'Delete' means 'erase' (i.e. render nonexistent or nonrecoverable)
- 'Remove' means 'take away and set aside' (but keep in existence)

Therefore, both terms should not be used together in documentation and naming (such as a method is named 'RemoveUser' but the documentation states 'Deletes the user from the database.')</value>
  </data>
  <data name="MiKo_1095_MessageFormat" xml:space="preserve">
    <value>Choose wisely between 'Delete' and 'Remove'</value>
  </data>
  <data name="MiKo_1095_Title" xml:space="preserve">
    <value>Do not use 'Delete' and 'Remove' both in names and documentation</value>
  </data>
  <data name="MiKo_1100_Description" xml:space="preserve">
    <value>A class that is marked as a unit test class should indicate via its name which type it tests.
The name should be constructed by having the name of the type under test as prefix and 'Tests' as suffix (e.g. for class 'MyXyzClass' the test class should be named 'MyXyzClassTests').</value>
  </data>
  <data name="MiKo_1100_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1100_Title" xml:space="preserve">
    <value>Test classes should start with the name of the type under test</value>
  </data>
  <data name="MiKo_1101_CodeFixTitle" xml:space="preserve">
    <value>Append 'Tests' suffix</value>
  </data>
  <data name="MiKo_1101_Description" xml:space="preserve">
    <value>A class that is marked as a unit test class should indicate that by the suffix 'Tests' as it normally contains multiple tests.</value>
  </data>
  <data name="MiKo_1101_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1101_Title" xml:space="preserve">
    <value>Test classes should end with 'Tests'</value>
  </data>
  <data name="MiKo_1102_CodeFixTitle" xml:space="preserve">
    <value>Remove test marker from name</value>
  </data>
  <data name="MiKo_1102_Description" xml:space="preserve">
    <value>A method that is marked as a unit test should not additionally indicate that it is a unit test by having 'Test' in its name.</value>
  </data>
  <data name="MiKo_1102_MessageFormat" xml:space="preserve">
    <value>Remove '{1}' from name</value>
  </data>
  <data name="MiKo_1102_Title" xml:space="preserve">
    <value>Test methods should not contain 'Test' in their names</value>
  </data>
  <data name="MiKo_1103_CodeFixTitle" xml:space="preserve">
    <value>Rename to 'PrepareTest'</value>
  </data>
  <data name="MiKo_1103_Description" xml:space="preserve">
    <value>A method that is marked as unit test initialization method should be named 'PrepareTest'.</value>
  </data>
  <data name="MiKo_1103_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1103_Title" xml:space="preserve">
    <value>Test initialization methods should be named 'PrepareTest'</value>
  </data>
  <data name="MiKo_1104_CodeFixTitle" xml:space="preserve">
    <value>Rename to 'CleanupTest'</value>
  </data>
  <data name="MiKo_1104_Description" xml:space="preserve">
    <value>A method that is marked as unit test cleanup method should be named 'CleanupTest'.</value>
  </data>
  <data name="MiKo_1104_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1104_Title" xml:space="preserve">
    <value>Test cleanup methods should be named 'CleanupTest'</value>
  </data>
  <data name="MiKo_1105_CodeFixTitle" xml:space="preserve">
    <value>Rename to 'PrepareTestEnvironment'</value>
  </data>
  <data name="MiKo_1105_Description" xml:space="preserve">
    <value>A method that is marked as one-time unit test initialization method should be named 'PrepareTestEnvironment'.</value>
  </data>
  <data name="MiKo_1105_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1105_Title" xml:space="preserve">
    <value>One-time test initialization methods should be named 'PrepareTestEnvironment'</value>
  </data>
  <data name="MiKo_1106_CodeFixTitle" xml:space="preserve">
    <value>Rename to 'CleanupTestEnvironment'</value>
  </data>
  <data name="MiKo_1106_Description" xml:space="preserve">
    <value>A method that is marked as one-time unit test cleanup method should be named 'CleanupTestEnvironment'.</value>
  </data>
  <data name="MiKo_1106_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1106_Title" xml:space="preserve">
    <value>One-time test cleanup methods should be named 'CleanupTestEnvironment'</value>
  </data>
  <data name="MiKo_1107_CodeFixTitle" xml:space="preserve">
    <value>Use underscores instead of Pascal-casing</value>
  </data>
  <data name="MiKo_1107_Description" xml:space="preserve">
    <value>For maintenance reasons, test methods whose names are written in Pascal-casing are hard to read.
To ease reading, use underscores between the different words instead.</value>
  </data>
  <data name="MiKo_1107_MessageFormat" xml:space="preserve">
    <value>Use underscores instead of Pascal-casing</value>
  </data>
  <data name="MiKo_1107_Title" xml:space="preserve">
    <value>Test methods should not be in Pascal-casing</value>
  </data>
  <data name="MiKo_1108_CodeFixTitle" xml:space="preserve">
    <value>Remove Mock suffix</value>
  </data>
  <data name="MiKo_1108_Description" xml:space="preserve">
    <value>For maintenance reasons, variables, parameters, properties and fields should be named about what they represent and not what they technically are.
Hence naming them e.g. 'Mock', 'Stub', 'Fake' or 'Shim' does not provide any additional value and is just some cluttering noise. In addition, those names put the developer's attention and focus on the wrong thing.</value>
  </data>
  <data name="MiKo_1108_MessageFormat" xml:space="preserve">
    <value>Do not name it 'Mock', 'Stub', 'Fake' or 'Shim'</value>
  </data>
  <data name="MiKo_1108_Title" xml:space="preserve">
    <value>Do not name variables, parameters, fields and properties 'Mock', 'Stub', 'Fake' or 'Shim'</value>
  </data>
  <data name="MiKo_1109_CodeFixTitle" xml:space="preserve">
    <value>Prefix with 'Testable' instead of suffix 'Ut'</value>
  </data>
  <data name="MiKo_1109_Description" xml:space="preserve">
    <value>Sometimes types or some of their functionality cannot be tested directly due to wrong visibility. To work around that, a solution is to inherit from such types and use that special type during test. Additionally, additional methods or properties are added to such types to access the orginal, invisible method resp. property.
Those specifically introduced types should be named as the original type, but prefixed with 'Testable' - they should not be suffixed with the hard-to-understand 'Ut' suffix.</value>
  </data>
  <data name="MiKo_1109_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1109_Title" xml:space="preserve">
    <value>Prefix testable types with 'Testable' instead of using the 'Ut' suffix</value>
  </data>
  <data name="MiKo_1110_CodeFixTitle" xml:space="preserve">
    <value>Append underscore</value>
  </data>
  <data name="MiKo_1110_Description" xml:space="preserve">
    <value>For maintenance reasons, parameterized test methods should be easy to read.
Therefore, they should be suffixed with underscores.</value>
  </data>
  <data name="MiKo_1110_MessageFormat" xml:space="preserve">
    <value>Suffix name with underscore</value>
  </data>
  <data name="MiKo_1110_Title" xml:space="preserve">
    <value>Test methods with parameters should be suffixed with underscore</value>
  </data>
  <data name="MiKo_1111_Description" xml:space="preserve">
    <value>For maintenance reasons, the names of test methods should be easy to read.
They should describe the scenario that is tested in a fluent way and not in a 'Yoda' like way.

Example:
"Send_EMailAddressValid_SendsMail" is hard to read. Much easier to read udn understand would be "Send_sends_email_to_valid_address".</value>
  </data>
  <data name="MiKo_1111_MessageFormat" xml:space="preserve">
    <value>Do not use Yoda speak for method names</value>
  </data>
  <data name="MiKo_1111_Title" xml:space="preserve">
    <value>Test methods should be named in a fluent way</value>
  </data>
  <data name="MiKo_1112_CodeFixTitle" xml:space="preserve">
    <value>Remove 'arbitrary' from name</value>
  </data>
  <data name="MiKo_1112_Description" xml:space="preserve">
    <value>Tests usually deal with arbitrary test data, hence there is no benefit in naming a field, parameter, variable (etc.) 'arbitrary'. That phrase can be removed without losing any meaning.</value>
  </data>
  <data name="MiKo_1112_MessageFormat" xml:space="preserve">
    <value>Remove 'arbitrary' from name</value>
  </data>
  <data name="MiKo_1112_Title" xml:space="preserve">
    <value>Do not name test data 'arbitrary'</value>
  </data>
  <data name="MiKo_1200_CodeFixTitle" xml:space="preserve">
    <value>Rename exception</value>
  </data>
  <data name="MiKo_1200_Description" xml:space="preserve">
    <value>To ease maintenance, exceptions in catch blocks should be named consistently.</value>
  </data>
  <data name="MiKo_1200_MessageFormat" xml:space="preserve">
    <value>Name it '{1}'</value>
  </data>
  <data name="MiKo_1200_Title" xml:space="preserve">
    <value>Name exceptions in catch blocks consistently</value>
  </data>
  <data name="MiKo_1201_CodeFixTitle" xml:space="preserve">
    <value>Rename exception</value>
  </data>
  <data name="MiKo_1201_Description" xml:space="preserve">
    <value>To ease maintenance, exceptions as parameters should be named consistently.</value>
  </data>
  <data name="MiKo_1201_MessageFormat" xml:space="preserve">
    <value>Name it '{1}' or '{2}'</value>
  </data>
  <data name="MiKo_1201_Title" xml:space="preserve">
    <value>Name exceptions as parameters consistently</value>
  </data>
  <data name="MiKo_1300_CodeFixTitle" xml:space="preserve">
    <value>Name it '_'</value>
  </data>
  <data name="MiKo_1300_Description" xml:space="preserve">
    <value>To ease maintenance and avoid visual noise, unimportant identifiers in lambdas should be consistently named '_'.</value>
  </data>
  <data name="MiKo_1300_MessageFormat" xml:space="preserve">
    <value>Name it '_' instead</value>
  </data>
  <data name="MiKo_1300_Title" xml:space="preserve">
    <value>Unimportant identifiers in lambda statements should be named '_'</value>
  </data>
  <data name="MiKo_1400_Description" xml:space="preserve">
    <value>Namespaces group functionalities, so their names should be in plural.</value>
  </data>
  <data name="MiKo_1400_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/names-of-namespaces</value>
  </data>
  <data name="MiKo_1400_MessageFormat" xml:space="preserve">
    <value>Use plural for namespace, such as '{1}'</value>
  </data>
  <data name="MiKo_1400_Title" xml:space="preserve">
    <value>Namespace names should be in plural</value>
  </data>
  <data name="MiKo_1401_Description" xml:space="preserve">
    <value>Namespaces should not contain any language specific (technical) name, such as 'Interfaces', 'Exceptions' or 'Enums'.</value>
  </data>
  <data name="MiKo_1401_MessageFormat" xml:space="preserve">
    <value>Do not use technical name '{1}' in namespace</value>
  </data>
  <data name="MiKo_1401_Title" xml:space="preserve">
    <value>Namespaces should not contain technical language names</value>
  </data>
  <data name="MiKo_1402_Description" xml:space="preserve">
    <value>Namespaces should not be named after WPF specific design patterns, such as 'Commands', 'Models', 'ViewModels' or 'Views'.
Models are Entities. Commands, ViewModels and Views belong together and are UI specific parts.</value>
  </data>
  <data name="MiKo_1402_MessageFormat" xml:space="preserve">
    <value>Do not use WPF design pattern name '{1}' in namespace</value>
  </data>
  <data name="MiKo_1402_Title" xml:space="preserve">
    <value>Namespaces should not be named after WPF specific design patterns</value>
  </data>
  <data name="MiKo_1403_Description" xml:space="preserve">
    <value>To avoid redundancy and confused developers, namespaces should not be named after any parent namespace. Instead, it should be made more clear into which namespace a type belongs by choosing a proper name.</value>
  </data>
  <data name="MiKo_1403_MessageFormat" xml:space="preserve">
    <value>Use another name for the namespace</value>
  </data>
  <data name="MiKo_1403_Title" xml:space="preserve">
    <value>Namespaces should not be named after any of their parent namespaces</value>
  </data>
  <data name="MiKo_1404_Description" xml:space="preserve">
    <value>Namespaces should not contain any unspecific name, such as 'Miscellaneous' or 'Utilities'.</value>
  </data>
  <data name="MiKo_1404_MessageFormat" xml:space="preserve">
    <value>Do not use '{1}' in namespace</value>
  </data>
  <data name="MiKo_1404_Title" xml:space="preserve">
    <value>Namespaces should not contain unspecific names</value>
  </data>
  <data name="MiKo_1405_Description" xml:space="preserve">
    <value>Namespaces should be named after features, not deployment details.
Most times, a Lib suffix only signals that the assembly is a DLL (dynamic link library). This information is not needed at all.
It does not matter if it is a library or an executable, what matters is the functionality it contains/provides.</value>
  </data>
  <data name="MiKo_1405_MessageFormat" xml:space="preserve">
    <value>Do not use '{1}' in namespace</value>
  </data>
  <data name="MiKo_1405_Title" xml:space="preserve">
    <value>Namespaces should not contain 'Lib'</value>
  </data>
  <data name="MiKo_1406_Description" xml:space="preserve">
    <value>To ease their finding, value converters should be placed and grouped in a specific namespace called 'Converters'.</value>
  </data>
  <data name="MiKo_1406_MessageFormat" xml:space="preserve">
    <value>Place in 'Converters' namespace</value>
  </data>
  <data name="MiKo_1406_Title" xml:space="preserve">
    <value>Value converters should be placed in 'Converters' namespace</value>
  </data>
  <data name="MiKo_1407_Description" xml:space="preserve">
    <value>A test should be located in the same namespace as the class it shall test.</value>
  </data>
  <data name="MiKo_1407_MessageFormat" xml:space="preserve">
    <value>Do not use 'Test' in namespace</value>
  </data>
  <data name="MiKo_1407_Title" xml:space="preserve">
    <value>Test namespaces should not contain 'Test'</value>
  </data>
  <data name="MiKo_1408_Description" xml:space="preserve">
    <value>To ease usage, extension method classes should be placed in same namespace as the extended types.
That allows an easy detection and use via IntelliSense.</value>
  </data>
  <data name="MiKo_1408_MessageFormat" xml:space="preserve">
    <value>Place class in namespace '{1}'</value>
  </data>
  <data name="MiKo_1408_Title" xml:space="preserve">
    <value>Extension methods should be placed in same namespace as the extended types</value>
  </data>
  <data name="MiKo_2000_CodeFixTitle" xml:space="preserve">
    <value>Fix malformed XML</value>
  </data>
  <data name="MiKo_2000_Description" xml:space="preserve">
    <value>Documentation should be valid XML so that it can be generated as API documentation/IntelliSense to support the developers.</value>
  </data>
  <data name="MiKo_2000_MessageFormat" xml:space="preserve">
    <value>Documentation is malformed (contains invalid characters, eg. '&amp;', '&gt;', '&lt;')</value>
  </data>
  <data name="MiKo_2000_Title" xml:space="preserve">
    <value>Documentation should be valid XML</value>
  </data>
  <data name="MiKo_2001_CodeFixTitle" xml:space="preserve">
    <value>Start comment with 'Occurs '</value>
  </data>
  <data name="MiKo_2001_Description" xml:space="preserve">
    <value>Events should be documented with 'Occurs ...' to indicate that events actually occur.</value>
  </data>
  <data name="MiKo_2001_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2001_Title" xml:space="preserve">
    <value>Events should be documented properly</value>
  </data>
  <data name="MiKo_2002_CodeFixTitle" xml:space="preserve">
    <value>Apply 'Provides data for the &lt;see cref="TODO"/&gt; event.' comment</value>
  </data>
  <data name="MiKo_2002_Description" xml:space="preserve">
    <value>To ease maintenance, classes that inherit from 'System.EventArgs' should be documented with 'Provides data for the &lt;see cref="XYZ" /&gt; event.' to indicate for which event they are valid.</value>
  </data>
  <data name="MiKo_2002_MessageFormat" xml:space="preserve">
    <value>&lt;summary&gt; should follow pattern: '{1} ... {2}'</value>
  </data>
  <data name="MiKo_2002_Title" xml:space="preserve">
    <value>EventArgs should be documented properly</value>
  </data>
  <data name="MiKo_2003_CodeFixTitle" xml:space="preserve">
    <value>Start comment with 'Handles the '</value>
  </data>
  <data name="MiKo_2003_Description" xml:space="preserve">
    <value>Documentation of an event handler should have a default starting phrase that describes what event gets handled.</value>
  </data>
  <data name="MiKo_2003_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2003_Title" xml:space="preserve">
    <value>Documentation of event handlers should have a default starting phrase</value>
  </data>
  <data name="MiKo_2004_CodeFixTitle" xml:space="preserve">
    <value>Fix comment of event handler parameter</value>
  </data>
  <data name="MiKo_2004_Description" xml:space="preserve">
    <value>Event method parameters should define what exactly they are.</value>
  </data>
  <data name="MiKo_2004_MessageFormat" xml:space="preserve">
    <value>Set Documentation to: '{2}'</value>
  </data>
  <data name="MiKo_2004_Title" xml:space="preserve">
    <value>Documentation of parameter name does not follow .NET Framework Guidelines for event handlers</value>
  </data>
  <data name="MiKo_2005_Description" xml:space="preserve">
    <value>Documentation should not contain the term 'event arg'. Instead, it should contain the reference to the specific class, such as '&lt;see cref="XyzEventArgs" /&gt;'.</value>
  </data>
  <data name="MiKo_2005_MessageFormat" xml:space="preserve">
    <value>Do not use term 'event arg'</value>
  </data>
  <data name="MiKo_2005_Title" xml:space="preserve">
    <value>Textual references to EventArgs should be documented properly</value>
  </data>
  <data name="MiKo_2006_CodeFixTitle" xml:space="preserve">
    <value>Apply standard comment to RoutedEvent</value>
  </data>
  <data name="MiKo_2006_Description" xml:space="preserve">
    <value>Routed events should be documented in the same way as they are documented by the .NET Framework.</value>
  </data>
  <data name="MiKo_2006_MessageFormat" xml:space="preserve">
    <value>&lt;{1}&gt; should be: '{2}'</value>
  </data>
  <data name="MiKo_2006_Title" xml:space="preserve">
    <value>Routed events should be documented as done by the .NET Framework</value>
  </data>
  <data name="MiKo_2010_CodeFixTitle" xml:space="preserve">
    <value>Append sealed text to comment</value>
  </data>
  <data name="MiKo_2010_Description" xml:space="preserve">
    <value>To ease their usage when it comes to inheritance, sealed classes should document the fact that they are sealed.</value>
  </data>
  <data name="MiKo_2010_MessageFormat" xml:space="preserve">
    <value>End &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2010_Title" xml:space="preserve">
    <value>Sealed classes should document being sealed</value>
  </data>
  <data name="MiKo_2011_CodeFixTitle" xml:space="preserve">
    <value>Remove sealed text to comment</value>
  </data>
  <data name="MiKo_2011_Description" xml:space="preserve">
    <value>Unsealed classes should not report that they are sealed.</value>
  </data>
  <data name="MiKo_2011_MessageFormat" xml:space="preserve">
    <value>&lt;summary&gt; should not contain: '{1}'</value>
  </data>
  <data name="MiKo_2011_Title" xml:space="preserve">
    <value>Unsealed classes should not lie about sealing</value>
  </data>
  <data name="MiKo_2012_CodeFixTitle" xml:space="preserve">
    <value>Fix meaningless phrase</value>
  </data>
  <data name="MiKo_2012_Description" xml:space="preserve">
    <value>To ease development and maintenance, the &lt;summary&gt; documentation should shortly describe a type's responsibility from the user's point of view. It should not be described from the implementer's point of view, except for callback interfaces.
So it should not start with or contain a meaningless phrase like 'Used to'. Instead, it should start with a phrase like 'Allows to ', 'Represents ' or 'Provides '.</value>
  </data>
  <data name="MiKo_2012_MessageFormat" xml:space="preserve">
    <value>&lt;summary&gt; should not {1} meaningless phrase: '{2}'</value>
  </data>
  <data name="MiKo_2012_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation should describe the type's responsibility</value>
  </data>
  <data name="MiKo_2013_CodeFixTitle" xml:space="preserve">
    <value>Start comment with '{0}'</value>
  </data>
  <data name="MiKo_2013_Description" xml:space="preserve">
    <value>To ease their usage, enums should specify what kind of values they define.</value>
  </data>
  <data name="MiKo_2013_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2013_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of Enums should have a default starting phrase</value>
  </data>
  <data name="MiKo_2014_CodeFixTitle" xml:space="preserve">
    <value>Apply standard 'Dispose' comment</value>
  </data>
  <data name="MiKo_2014_Description" xml:space="preserve">
    <value>Dispose methods should be documented in the same way as they are documented by the .NET Framework.</value>
  </data>
  <data name="MiKo_2014_MessageFormat" xml:space="preserve">
    <value>Set Documentation to: '{1}'</value>
  </data>
  <data name="MiKo_2014_Title" xml:space="preserve">
    <value>Dispose methods should be documented as done by the .NET Framework</value>
  </data>
  <data name="MiKo_2015_CodeFixTitle" xml:space="preserve">
    <value>Replace term 'fire'</value>
  </data>
  <data name="MiKo_2015_Description" xml:space="preserve">
    <value>The term 'Fire' is a negative term. Employees get fired (or guns), but not events or exceptions. Events get raised and exceptions get thrown.</value>
  </data>
  <data name="MiKo_2015_MessageFormat" xml:space="preserve">
    <value>Use {1} instead of {2} in documentation</value>
  </data>
  <data name="MiKo_2015_Title" xml:space="preserve">
    <value>Documentation should use 'raise' or 'throw' instead of 'fire'</value>
  </data>
  <data name="MiKo_2016_CodeFixTitle" xml:space="preserve">
    <value>Start comment with '{0}'</value>
  </data>
  <data name="MiKo_2016_Description" xml:space="preserve">
    <value>Documentation for asynchronous methods should indicate that method is run asynchronously.</value>
  </data>
  <data name="MiKo_2016_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2016_Title" xml:space="preserve">
    <value>Documentation for asynchronous methods should start with specific phrase</value>
  </data>
  <data name="MiKo_2017_CodeFixTitle" xml:space="preserve">
    <value>Apply standard comment to DependencyProperty</value>
  </data>
  <data name="MiKo_2017_Description" xml:space="preserve">
    <value>Dependency properties should be documented in the same way as they are documented by the .NET Framework.</value>
  </data>
  <data name="MiKo_2017_MessageFormat" xml:space="preserve">
    <value>&lt;{1}&gt; should be: '{2}'</value>
  </data>
  <data name="MiKo_2017_Title" xml:space="preserve">
    <value>Dependency properties should be documented as done by the .NET Framework</value>
  </data>
  <data name="MiKo_2018_CodeFixTitle" xml:space="preserve">
    <value>Start summary with '{0}'</value>
  </data>
  <data name="MiKo_2018_Description" xml:space="preserve">
    <value>The terms 'Check' or 'Test' are ambiguous. If validation of parameters is meant, use something like 'Validates' or 'Verifies'. If a check for a specific state is meant, use 'Determines whether' instead.</value>
  </data>
  <data name="MiKo_2018_MessageFormat" xml:space="preserve">
    <value>Use '{2}' instead of '{1}'</value>
  </data>
  <data name="MiKo_2018_Title" xml:space="preserve">
    <value>Documentation should not use the ambiguous terms 'Check' or 'Test'</value>
  </data>
  <data name="MiKo_2019_Description" xml:space="preserve">
    <value>&lt;summary&gt; documentation should start with a third person singular verb as it shall be a short description of the functionality that the class, property, etc. provides or represents.</value>
  </data>
  <data name="MiKo_2019_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with a third person singular verb</value>
  </data>
  <data name="MiKo_2019_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation should start with a third person singular verb (for example "Provides ")</value>
  </data>
  <data name="MiKo_2020_CodeFixTitle" xml:space="preserve">
    <value>Use &lt;inheritdoc/&gt;</value>
  </data>
  <data name="MiKo_2020_Description" xml:space="preserve">
    <value>It does not make sense to use a &lt;summary&gt; documentation that only reference something else via &lt;see cref="..." /&gt; as IntelliSense does not show these descriptions. For such a scenario &lt;inheritdoc /&gt; should be used.</value>
  </data>
  <data name="MiKo_2020_MessageFormat" xml:space="preserve">
    <value>Use &lt;inheritdoc /&gt; instead</value>
  </data>
  <data name="MiKo_2020_Title" xml:space="preserve">
    <value>Inherited documentation should be used with &lt;inheritdoc /&gt; marker</value>
  </data>
  <data name="MiKo_2021_Description" xml:space="preserve">
    <value>The documentation of parameters should describe what they represent.</value>
  </data>
  <data name="MiKo_2021_MessageFormat" xml:space="preserve">
    <value>Start documentation with: {1}</value>
  </data>
  <data name="MiKo_2021_Title" xml:space="preserve">
    <value>Documentation of parameter should have a default starting phrase</value>
  </data>
  <data name="MiKo_2022_CodeFixTitle" xml:space="preserve">
    <value>Fix comment start of [out] parameter</value>
  </data>
  <data name="MiKo_2022_Description" xml:space="preserve">
    <value>The documentation of [out] parameters should start with the success case.</value>
  </data>
  <data name="MiKo_2022_MessageFormat" xml:space="preserve">
    <value>Start documentation with: {1}</value>
  </data>
  <data name="MiKo_2022_Title" xml:space="preserve">
    <value>Documentation of [out] parameters should have a default starting phrase</value>
  </data>
  <data name="MiKo_2023_CodeFixTitle" xml:space="preserve">
    <value>Fix comment start of Boolean parameter</value>
  </data>
  <data name="MiKo_2023_Description" xml:space="preserve">
    <value>The documentation of a Boolean as parameter should have a specific phrase that first describes the 'true' case and then the 'false' case.</value>
  </data>
  <data name="MiKo_2023_MessageFormat" xml:space="preserve">
    <value>Documentation should follow pattern: '{1} ... {2}'</value>
  </data>
  <data name="MiKo_2023_Title" xml:space="preserve">
    <value>Documentation of Boolean parameters should have a default starting phrase</value>
  </data>
  <data name="MiKo_2024_CodeFixTitle" xml:space="preserve">
    <value>Fix comment start of Enum parameter</value>
  </data>
  <data name="MiKo_2024_Description" xml:space="preserve">
    <value>The documentation of Enum parameters should start with a phrase that specifies what will be done with the Enum.</value>
  </data>
  <data name="MiKo_2024_MessageFormat" xml:space="preserve">
    <value>Start documentation with: {1}</value>
  </data>
  <data name="MiKo_2024_Title" xml:space="preserve">
    <value>Documentation of Enum parameters should have a default starting phrase</value>
  </data>
  <data name="MiKo_2025_CodeFixTitle" xml:space="preserve">
    <value>Fix comment start of CancellationToken</value>
  </data>
  <data name="MiKo_2025_Description" xml:space="preserve">
    <value>The documentation of 'CancellationToken' parameters should start with a phrase that describes how it is used.</value>
  </data>
  <data name="MiKo_2025_MessageFormat" xml:space="preserve">
    <value>Start documentation with: {1}</value>
  </data>
  <data name="MiKo_2025_Title" xml:space="preserve">
    <value>Documentation of 'CancellationToken' parameters should have a default starting phrase</value>
  </data>
  <data name="MiKo_2026_Description" xml:space="preserve">
    <value>The documentation should not state that a parameter is unused although it is still in use.</value>
  </data>
  <data name="MiKo_2026_MessageFormat" xml:space="preserve">
    <value>Documentation lies about being unused</value>
  </data>
  <data name="MiKo_2026_Title" xml:space="preserve">
    <value>Used parameters should not be documented to be unused</value>
  </data>
  <data name="MiKo_2027_CodeFixTitle" xml:space="preserve">
    <value>Fix comment start of parameter of serialization constructor</value>
  </data>
  <data name="MiKo_2027_Description" xml:space="preserve">
    <value>To ease the usage, the documentation of the parameters of the serialization constructors shall have a specific phrase that describes what they contain.</value>
  </data>
  <data name="MiKo_2027_MessageFormat" xml:space="preserve">
    <value>Set Documentation to: '{1}'</value>
  </data>
  <data name="MiKo_2027_Title" xml:space="preserve">
    <value>Serialization constructor parameters shall be documented with a specific phrase</value>
  </data>
  <data name="MiKo_2028_Description" xml:space="preserve">
    <value>The documentation of parameters should describe what they represent and what they are used for. Only stating the name of the parameter is simply not enough.</value>
  </data>
  <data name="MiKo_2028_MessageFormat" xml:space="preserve">
    <value>Documentation should contain more than just the parameter name</value>
  </data>
  <data name="MiKo_2028_Title" xml:space="preserve">
    <value>Documentation of parameter should not just contain the name of the parameter</value>
  </data>
  <data name="MiKo_2029_CodeFixTitle" xml:space="preserve">
    <value>Remove 'cref' value from &lt;inheritdoc/&gt;</value>
  </data>
  <data name="MiKo_2029_Description" xml:space="preserve">
    <value>Instead of faking an XML documentation by using &lt;inheritdoc&gt; with a 'cref' to itself, a well-written &lt;summary&gt; XML documentation should be used.</value>
  </data>
  <data name="MiKo_2029_MessageFormat" xml:space="preserve">
    <value>Do not use &lt;inheritdoc cref="{0}" /&gt;</value>
  </data>
  <data name="MiKo_2029_Title" xml:space="preserve">
    <value>&lt;inheritdoc&gt; documentation should not use a 'cref' to itself</value>
  </data>
  <data name="MiKo_2030_Description" xml:space="preserve">
    <value>The documentation of a return value should have a default starting phrase that describes the returned value in more detail.</value>
  </data>
  <data name="MiKo_2030_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with: '{2}'</value>
  </data>
  <data name="MiKo_2030_Title" xml:space="preserve">
    <value>Documentation of return value should have a default starting phrase</value>
  </data>
  <data name="MiKo_2031_CodeFixTitle" xml:space="preserve">
    <value>Fix return comment</value>
  </data>
  <data name="MiKo_2031_Description" xml:space="preserve">
    <value>The documentation of a Task as return value should have a default (starting) phrase.</value>
  </data>
  <data name="MiKo_2031_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with: '{2}'</value>
  </data>
  <data name="MiKo_2031_Title" xml:space="preserve">
    <value>Documentation of Task return value should have a specific (starting) phrase</value>
  </data>
  <data name="MiKo_2032_CodeFixTitle" xml:space="preserve">
    <value>Fix return comment</value>
  </data>
  <data name="MiKo_2032_Description" xml:space="preserve">
    <value>The documentation of a Boolean as return value should have a specific phrase that first describes the 'true' case and then the 'false' case.</value>
  </data>
  <data name="MiKo_2032_MessageFormat" xml:space="preserve">
    <value>&lt;{1}&gt; should follow pattern: '{2} ... {3}'</value>
  </data>
  <data name="MiKo_2032_Title" xml:space="preserve">
    <value>Documentation of Boolean return value should have a specific phrase</value>
  </data>
  <data name="MiKo_2033_CodeFixTitle" xml:space="preserve">
    <value>Fix return comment</value>
  </data>
  <data name="MiKo_2033_Description" xml:space="preserve">
    <value>The documentation of a String as return value should have a specific phrase.</value>
  </data>
  <data name="MiKo_2033_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with: '{2}'</value>
  </data>
  <data name="MiKo_2033_Title" xml:space="preserve">
    <value>Documentation of String return value should have a default starting phrase</value>
  </data>
  <data name="MiKo_2034_CodeFixTitle" xml:space="preserve">
    <value>Fix return comment</value>
  </data>
  <data name="MiKo_2034_Description" xml:space="preserve">
    <value>The documentation of an Enum as return value should have a specific phrase.</value>
  </data>
  <data name="MiKo_2034_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with: '{2}'</value>
  </data>
  <data name="MiKo_2034_Title" xml:space="preserve">
    <value>Documentation of Enum return value should have a default starting phrase</value>
  </data>
  <data name="MiKo_2035_CodeFixTitle" xml:space="preserve">
    <value>Fix return comment</value>
  </data>
  <data name="MiKo_2035_Description" xml:space="preserve">
    <value>The documentation of a collection as return value should have a specific phrase.</value>
  </data>
  <data name="MiKo_2035_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with: '{2}'</value>
  </data>
  <data name="MiKo_2035_Title" xml:space="preserve">
    <value>Documentation of collection return value should have a default starting phrase</value>
  </data>
  <data name="MiKo_2036_CodeFixTitle_DefaultFalse" xml:space="preserve">
    <value>Fix comment for default value 'false'</value>
  </data>
  <data name="MiKo_2036_CodeFixTitle_DefaultTrue" xml:space="preserve">
    <value>Fix comment for default value 'true'</value>
  </data>
  <data name="MiKo_2036_CodeFixTitle_Enum" xml:space="preserve">
    <value>Fix comment for enum default value</value>
  </data>
  <data name="MiKo_2036_CodeFixTitle_NoDefault" xml:space="preserve">
    <value>Fix comment for no default value</value>
  </data>
  <data name="MiKo_2036_Description" xml:space="preserve">
    <value>The documentation of Boolean or Enum properties shall end with a phrase that describes the value that is returned per default.</value>
  </data>
  <data name="MiKo_2036_MessageFormat" xml:space="preserve">
    <value>End &lt;{1}&gt; with: '{2}'
Or with: '{3}'</value>
  </data>
  <data name="MiKo_2036_Title" xml:space="preserve">
    <value>Documentation of Boolean or Enum property shall describe the default value</value>
  </data>
  <data name="MiKo_2037_CodeFixTitle" xml:space="preserve">
    <value>Apply standard comment to command property</value>
  </data>
  <data name="MiKo_2037_Description" xml:space="preserve">
    <value>The documentation of a property that returns a command should start with a specific phrase that describes what command the property returns.</value>
  </data>
  <data name="MiKo_2037_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with: '{2}'</value>
  </data>
  <data name="MiKo_2037_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of command properties should have a default starting phrase</value>
  </data>
  <data name="MiKo_2038_CodeFixTitle" xml:space="preserve">
    <value>Apply standard comment to command</value>
  </data>
  <data name="MiKo_2038_Description" xml:space="preserve">
    <value>The documentation of a command should start with a specific phrase that describes what the command does.</value>
  </data>
  <data name="MiKo_2038_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with: '{2}'</value>
  </data>
  <data name="MiKo_2038_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of command should have a default starting phrase</value>
  </data>
  <data name="MiKo_2039_CodeFixTitle" xml:space="preserve">
    <value>Apply standard extension methods comment to class</value>
  </data>
  <data name="MiKo_2039_Description" xml:space="preserve">
    <value>The documentation of a class that contains extension methods should start with a specific phrase that describes what the class provides.</value>
  </data>
  <data name="MiKo_2039_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with: '{2}'</value>
  </data>
  <data name="MiKo_2039_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of classes that contain extension methods should have a default starting phrase</value>
  </data>
  <data name="MiKo_2040_CodeFixTitle" xml:space="preserve">
    <value>Use &lt;see langword="..."/&gt;</value>
  </data>
  <data name="MiKo_2040_Description" xml:space="preserve">
    <value>To support other languages than C#, use '&lt;see langword="..."/&gt;' instead of '&lt;c&gt;...&lt;/c&gt;'.</value>
  </data>
  <data name="MiKo_2040_MessageFormat" xml:space="preserve">
    <value>Use '{2}' instead of '{1}'</value>
  </data>
  <data name="MiKo_2040_Title" xml:space="preserve">
    <value>&lt;see langword="..."/&gt; should be used instead of &lt;c&gt;...&lt;/c&gt;</value>
  </data>
  <data name="MiKo_2041_CodeFixTitle" xml:space="preserve">
    <value>Place XML tag outside &lt;summary&gt;</value>
  </data>
  <data name="MiKo_2041_Description" xml:space="preserve">
    <value>The &lt;summary&gt; documentation should only contain a short summary description. Other documentation should be provided by the other XML tags in parallel to the &lt;summary&gt;.</value>
  </data>
  <data name="MiKo_2041_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/xmldoc/recommended-tags-for-documentation-comments</value>
  </data>
  <data name="MiKo_2041_MessageFormat" xml:space="preserve">
    <value>&lt;summary&gt; should not contain: '&lt;{0}/&gt;'</value>
  </data>
  <data name="MiKo_2041_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation should not contain other documentation tags</value>
  </data>
  <data name="MiKo_2042_CodeFixTitle" xml:space="preserve">
    <value>Replace &lt;br/&gt; with &lt;para/&gt;</value>
  </data>
  <data name="MiKo_2042_Description" xml:space="preserve">
    <value>The documentation should use the '&lt;para/&gt;' XML tags instead of '&lt;br/&gt;' or '&lt;p/&gt;' HTML tags.</value>
  </data>
  <data name="MiKo_2042_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/xmldoc/para</value>
  </data>
  <data name="MiKo_2042_MessageFormat" xml:space="preserve">
    <value>Use '&lt;para/&gt;' instead of '{1}'</value>
  </data>
  <data name="MiKo_2042_Title" xml:space="preserve">
    <value>Documentation should use '&lt;para/&gt;' XML tags instead of '&lt;br/&gt;' HTML tags</value>
  </data>
  <data name="MiKo_2043_CodeFixTitle" xml:space="preserve">
    <value>Start summary with 'Encapsulates a method that '</value>
  </data>
  <data name="MiKo_2043_Description" xml:space="preserve">
    <value>The documentation of a custom delegate should have a default starting phrase to indicate what the delegate encapsulates.</value>
  </data>
  <data name="MiKo_2043_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with: '{2}'</value>
  </data>
  <data name="MiKo_2043_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of custom delegates should have a default starting phrase</value>
  </data>
  <data name="MiKo_2044_CodeFixTitle" xml:space="preserve">
    <value>Use &lt;paramref&gt; tag for parameter</value>
  </data>
  <data name="MiKo_2044_Description" xml:space="preserve">
    <value>Method parameters should be referenced via &lt;paramref name="..."/&gt; inside the documentation.</value>
  </data>
  <data name="MiKo_2044_MessageFormat" xml:space="preserve">
    <value>Fix incorrect parameter reference '{1}'</value>
  </data>
  <data name="MiKo_2044_Title" xml:space="preserve">
    <value>Documentation references method parameters correctly</value>
  </data>
  <data name="MiKo_2045_CodeFixTitle" xml:space="preserve">
    <value>Fix parameter reference</value>
  </data>
  <data name="MiKo_2045_Description" xml:space="preserve">
    <value>The &lt;summary&gt; documentation should not reference method parameters as its only purpose is to give a brief description.</value>
  </data>
  <data name="MiKo_2045_MessageFormat" xml:space="preserve">
    <value>&lt;summary&gt; should not contain parameter reference ' {0} '</value>
  </data>
  <data name="MiKo_2045_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation should not reference parameters</value>
  </data>
  <data name="MiKo_2046_Description" xml:space="preserve">
    <value>The XML documentation should reference type parameters properly via '&lt;typeparamref name="..." /&gt;'.</value>
  </data>
  <data name="MiKo_2046_MessageFormat" xml:space="preserve">
    <value>Replace invalid type parameter reference '{1}' by '{2}'</value>
  </data>
  <data name="MiKo_2046_Title" xml:space="preserve">
    <value>Documentation should reference type parameters correctly</value>
  </data>
  <data name="MiKo_2047_Description" xml:space="preserve">
    <value>The documentation of an Attribute should start with a specific phrase that describes its purpose.</value>
  </data>
  <data name="MiKo_2047_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: {1}</value>
  </data>
  <data name="MiKo_2047_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of Attributes should have a default starting phrase</value>
  </data>
  <data name="MiKo_2048_CodeFixTitle" xml:space="preserve">
    <value>Start comment with '{0}'</value>
  </data>
  <data name="MiKo_2048_Description" xml:space="preserve">
    <value>The documentation of a value converters should start with a specific phrase that describes what they convert.</value>
  </data>
  <data name="MiKo_2048_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2048_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of value converters should have a default starting phrase</value>
  </data>
  <data name="MiKo_2049_Description" xml:space="preserve">
    <value>The term 'will be' is not explicit enough and it uses the wrong tense. Instead, a term such as 'is' gets to the point and uses present tense.</value>
  </data>
  <data name="MiKo_2049_MessageFormat" xml:space="preserve">
    <value>Use 'is' instead of 'will be' in documentation</value>
  </data>
  <data name="MiKo_2049_Title" xml:space="preserve">
    <value>Documentation should be more explicit and not use 'will be'</value>
  </data>
  <data name="MiKo_2050_CodeFixTitle" xml:space="preserve">
    <value>Apply standard exception comment</value>
  </data>
  <data name="MiKo_2050_Description" xml:space="preserve">
    <value>The documentation of exceptions should follow the .NET Framework documentation.</value>
  </data>
  <data name="MiKo_2050_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with: '{2}'</value>
  </data>
  <data name="MiKo_2050_Title" xml:space="preserve">
    <value>Exceptions should be documented following the .NET Framework</value>
  </data>
  <data name="MiKo_2051_CodeFixTitle" xml:space="preserve">
    <value>Fix exception comment</value>
  </data>
  <data name="MiKo_2051_Description" xml:space="preserve">
    <value>The documentation of a thrown exception should be a simple condition phrase, such as: 'The item is not available'.</value>
  </data>
  <data name="MiKo_2051_MessageFormat" xml:space="preserve">
    <value>Use condition form to document thrown exception</value>
  </data>
  <data name="MiKo_2051_Title" xml:space="preserve">
    <value>Thrown Exceptions should be documented as kind of a condition (such as '&lt;paramref name="xyz"/&gt; is &lt;c&gt;42&lt;/c&gt;')</value>
  </data>
  <data name="MiKo_2052_CodeFixTitle" xml:space="preserve">
    <value>Fix exception comment</value>
  </data>
  <data name="MiKo_2052_Description" xml:space="preserve">
    <value>The documentation of an ArgumentNullException being thrown should be a specific phrase.</value>
  </data>
  <data name="MiKo_2052_MessageFormat" xml:space="preserve">
    <value>{1} should be something like:

{2}</value>
  </data>
  <data name="MiKo_2052_Title" xml:space="preserve">
    <value>Throwing of ArgumentNullException should be documented using a default phrase</value>
  </data>
  <data name="MiKo_2053_Description" xml:space="preserve">
    <value>The documentation of an ArgumentNullException should not refer to a value type parameter as that can never be null.</value>
  </data>
  <data name="MiKo_2053_MessageFormat" xml:space="preserve">
    <value>Remove '{2}' from &lt;exception cref="ArgumentNullException"/&gt; as '{1}' is a value type</value>
  </data>
  <data name="MiKo_2053_Title" xml:space="preserve">
    <value>Throwing of ArgumentNullException should be documented only for reference type parameters</value>
  </data>
  <data name="MiKo_2054_CodeFixTitle" xml:space="preserve">
    <value>Fix exception comment</value>
  </data>
  <data name="MiKo_2054_Description" xml:space="preserve">
    <value>The documentation of an ArgumentException being thrown should have a specific starting phrase.</value>
  </data>
  <data name="MiKo_2054_MessageFormat" xml:space="preserve">
    <value>{1} should be something like:
{2}</value>
  </data>
  <data name="MiKo_2054_Title" xml:space="preserve">
    <value>Throwing of ArgumentException should be documented using a default starting phrase</value>
  </data>
  <data name="MiKo_2055_CodeFixTitle" xml:space="preserve">
    <value>Fix exception comment</value>
  </data>
  <data name="MiKo_2055_Description" xml:space="preserve">
    <value>The documentation of an ArgumentOutOfRangeException being thrown should have a specific starting phrase.</value>
  </data>
  <data name="MiKo_2055_MessageFormat" xml:space="preserve">
    <value>{1} should be something like:
{2}</value>
  </data>
  <data name="MiKo_2055_Title" xml:space="preserve">
    <value>Throwing of ArgumentOutOfRangeException should be documented using a default starting phrase</value>
  </data>
  <data name="MiKo_2056_CodeFixTitle" xml:space="preserve">
    <value>Apply default ending comment to documentation of thrown 'ObjectDisposedException'</value>
  </data>
  <data name="MiKo_2056_Description" xml:space="preserve">
    <value>The documentation of an ObjectDisposedException being thrown should have a specific ending phrase.</value>
  </data>
  <data name="MiKo_2056_MessageFormat" xml:space="preserve">
    <value>{1} should end with: '{2}'</value>
  </data>
  <data name="MiKo_2056_Title" xml:space="preserve">
    <value>Throwing of ObjectDisposedException should be documented using a default ending phrase</value>
  </data>
  <data name="MiKo_2057_CodeFixTitle" xml:space="preserve">
    <value>Remove exception comment</value>
  </data>
  <data name="MiKo_2057_Description" xml:space="preserve">
    <value>Types that do not inherit from 'IDisposable' cannot be disposed. Hence they shall not throw an ObjectDisposedException.</value>
  </data>
  <data name="MiKo_2057_MessageFormat" xml:space="preserve">
    <value>Remove '{1}' because type does not inherit from 'IDisposable'</value>
  </data>
  <data name="MiKo_2057_Title" xml:space="preserve">
    <value>Types that are not disposable shall not throw an ObjectDisposedException</value>
  </data>
  <data name="MiKo_2059_CodeFixTitle" xml:space="preserve">
    <value>Consolidate exception documentation</value>
  </data>
  <data name="MiKo_2059_Description" xml:space="preserve">
    <value>To ease reading, thrown exceptions should be documented only once and not multiple times. So the documentation of those exceptions should be consolidated.</value>
  </data>
  <data name="MiKo_2059_MessageFormat" xml:space="preserve">
    <value>Consolidate the documentation of &lt;exception cref='{1}'&gt;</value>
  </data>
  <data name="MiKo_2059_Title" xml:space="preserve">
    <value>Multiple documentation of same exception should be consolidated into one</value>
  </data>
  <data name="MiKo_2060_CodeFixTitle" xml:space="preserve">
    <value>Apply standard comment to factory</value>
  </data>
  <data name="MiKo_2060_Description" xml:space="preserve">
    <value>The documentation of factories should be uniform and consistent.</value>
  </data>
  <data name="MiKo_2060_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2060_Title" xml:space="preserve">
    <value>Factories should be documented in an uniform way</value>
  </data>
  <data name="MiKo_2070_CodeFixTitle" xml:space="preserve">
    <value>Replace 'Return' in comment</value>
  </data>
  <data name="MiKo_2070_Description" xml:space="preserve">
    <value>If a method comment starts with 'Returns', then it focuses on the return value but not on the purpose (responsibility) of the method.
Instead, the documentation should describe what the method is intended to do.</value>
  </data>
  <data name="MiKo_2070_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2070_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation should not start with 'Returns'</value>
  </data>
  <data name="MiKo_2071_Description" xml:space="preserve">
    <value>Enum types are no boolean values. Hence the documentation should not contain any phrase that would handle enums as if they were booleans (such as it would be the case in phrase 'indicates whether').</value>
  </data>
  <data name="MiKo_2071_MessageFormat" xml:space="preserve">
    <value>Do not use '{1}' in &lt;summary&gt;</value>
  </data>
  <data name="MiKo_2071_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation for methods that return Enum types should not contain phrase for boolean type</value>
  </data>
  <data name="MiKo_2072_CodeFixTitle" xml:space="preserve">
    <value>Start summary with 'Attempts to'</value>
  </data>
  <data name="MiKo_2072_Description" xml:space="preserve">
    <value>'Try' methods attempt to achieve something. So their &lt;summary&gt; documentation should start with the phrase 'Attempts to '.</value>
  </data>
  <data name="MiKo_2072_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with 'Attempts to '</value>
  </data>
  <data name="MiKo_2072_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation should not start with 'Try'</value>
  </data>
  <data name="MiKo_2073_CodeFixTitle" xml:space="preserve">
    <value>Start summary with 'Determines whether'</value>
  </data>
  <data name="MiKo_2073_Description" xml:space="preserve">
    <value>'Contain' methods attempt to determine if something exists inside something else. So their &lt;summary&gt; documentation should start with the phrase 'Determines whether '.</value>
  </data>
  <data name="MiKo_2073_MessageFormat" xml:space="preserve">
    <value>Start summary with 'Determines whether'</value>
  </data>
  <data name="MiKo_2073_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of 'Contains' methods should start with 'Determines whether '</value>
  </data>
  <data name="MiKo_2074_CodeFixTitle" xml:space="preserve">
    <value>Fix comment of parameter</value>
  </data>
  <data name="MiKo_2074_Description" xml:space="preserve">
    <value>'Contain' methods attempt to determine if the value of a given parameter exists inside something. So the &lt;param&gt; documentation of the given parameter should end with the phrase ' to seek.'.</value>
  </data>
  <data name="MiKo_2074_MessageFormat" xml:space="preserve">
    <value>&lt;param name="{0}"&gt; should end with: '{1}'</value>
  </data>
  <data name="MiKo_2074_Title" xml:space="preserve">
    <value>Documentation of parameter of 'Contains' method should have a default ending phrase</value>
  </data>
  <data name="MiKo_2080_CodeFixTitle" xml:space="preserve">
    <value>Start field with default phrase</value>
  </data>
  <data name="MiKo_2080_Description" xml:space="preserve">
    <value>The documentation of fields should start with a default phrase.</value>
  </data>
  <data name="MiKo_2080_MessageFormat" xml:space="preserve">
    <value>Start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2080_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of fields should have a default starting phrase</value>
  </data>
  <data name="MiKo_2081_CodeFixTitle" xml:space="preserve">
    <value>Append read-only text</value>
  </data>
  <data name="MiKo_2081_Description" xml:space="preserve">
    <value>The documentation of a public-visible read-only field should indicate that it is read-only.</value>
  </data>
  <data name="MiKo_2081_MessageFormat" xml:space="preserve">
    <value>End &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2081_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of public-visible read-only fields should have a default ending phrase</value>
  </data>
  <data name="MiKo_2082_Description" xml:space="preserve">
    <value>The summary of an Enum member should not use any phrase that belongs to the summary of the Enum itself.
Such phrases are for example 'Defines', 'Indicates' or 'Specifies'. Instead, the Enum member summary should describe the meaning of the member itself.</value>
  </data>
  <data name="MiKo_2082_MessageFormat" xml:space="preserve">
    <value>Do not start &lt;summary&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2082_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation of Enum members should not start with default starting phrases of Enum &lt;summary&gt; documentation</value>
  </data>
  <data name="MiKo_2090_CodeFixTitle" xml:space="preserve">
    <value>Apply standard comment</value>
  </data>
  <data name="MiKo_2090_Description" xml:space="preserve">
    <value>To ease development and usage, the XML documentation for equality operators shall have a common default phrase.</value>
  </data>
  <data name="MiKo_2090_MessageFormat" xml:space="preserve">
    <value>&lt;{1}&gt; should be: '{2}'</value>
  </data>
  <data name="MiKo_2090_Title" xml:space="preserve">
    <value>Documentation for equality operator shall have default phrase</value>
  </data>
  <data name="MiKo_2091_CodeFixTitle" xml:space="preserve">
    <value>Apply standard comment</value>
  </data>
  <data name="MiKo_2091_Description" xml:space="preserve">
    <value>To ease development and usage, the XML documentation for inequality operators shall have a common default phrase.</value>
  </data>
  <data name="MiKo_2091_MessageFormat" xml:space="preserve">
    <value>&lt;{1}&gt; should be: '{2}'</value>
  </data>
  <data name="MiKo_2091_Title" xml:space="preserve">
    <value>Documentation for inequality operator shall have default phrase</value>
  </data>
  <data name="MiKo_2100_CodeFixTitle" xml:space="preserve">
    <value>Start comment with '{0}'</value>
  </data>
  <data name="MiKo_2100_Description" xml:space="preserve">
    <value>To ease usage, the example documentation should start with a phrase that shortly describes what the given example demonstrates.</value>
  </data>
  <data name="MiKo_2100_MessageFormat" xml:space="preserve">
    <value>Start &lt;example&gt; with: '{1}'</value>
  </data>
  <data name="MiKo_2100_Title" xml:space="preserve">
    <value>&lt;example&gt; documentation should start with descriptive default phrase</value>
  </data>
  <data name="MiKo_2101_CodeFixTitle" xml:space="preserve">
    <value>Surround sample code with '&lt;code&gt;'</value>
  </data>
  <data name="MiKo_2101_Description" xml:space="preserve">
    <value>To ease reading, example documentation should place code samples inside &lt;code&gt; tags so that IntelliSense or any XML documentation tool can format them in a special way.</value>
  </data>
  <data name="MiKo_2101_MessageFormat" xml:space="preserve">
    <value>Place sample code in &lt;example&gt; inside '&lt;code&gt;' tags</value>
  </data>
  <data name="MiKo_2101_Title" xml:space="preserve">
    <value>&lt;example&gt; documentation should show code example in &lt;code&gt; tags</value>
  </data>
  <data name="MiKo_2200_Description" xml:space="preserve">
    <value>Documentation should start with a capitalized letter to have a full sentence.</value>
  </data>
  <data name="MiKo_2200_MessageFormat" xml:space="preserve">
    <value>Start &lt;{1}&gt; with capitalized letter</value>
  </data>
  <data name="MiKo_2200_Title" xml:space="preserve">
    <value>Use a capitalized letter to start the comment</value>
  </data>
  <data name="MiKo_2201_Description" xml:space="preserve">
    <value>Documentation sentences should start with a capitalized letter to have a full sentence.</value>
  </data>
  <data name="MiKo_2201_MessageFormat" xml:space="preserve">
    <value>Start the sentence(s) in &lt;{1}&gt; with capitalized letter</value>
  </data>
  <data name="MiKo_2201_Title" xml:space="preserve">
    <value>Use a capitalized letter to start the sentences in the comment</value>
  </data>
  <data name="MiKo_2202_CodeFixTitle" xml:space="preserve">
    <value>Change 'id' into 'identifier'</value>
  </data>
  <data name="MiKo_2202_Description" xml:space="preserve">
    <value>The XML documentation should not use the abbreviation 'id'. Instead, it should clearly document that this is an identifier. Hence, it should use the term 'identifier' instead.</value>
  </data>
  <data name="MiKo_2202_MessageFormat" xml:space="preserve">
    <value>Use 'identifier' instead of 'id'</value>
  </data>
  <data name="MiKo_2202_Title" xml:space="preserve">
    <value>Documentation should use the term 'identifier' instead of 'id'</value>
  </data>
  <data name="MiKo_2203_CodeFixTitle" xml:space="preserve">
    <value>Change 'GUID' into 'unique identifier'</value>
  </data>
  <data name="MiKo_2203_Description" xml:space="preserve">
    <value>The XML documentation should not use the abbreviation 'guid'. Instead, it should clearly document that this is an unique identifier. Hence, it should use the term 'unique identifier' instead.</value>
  </data>
  <data name="MiKo_2203_MessageFormat" xml:space="preserve">
    <value>Use 'unique identifier' instead of 'guid'</value>
  </data>
  <data name="MiKo_2203_Title" xml:space="preserve">
    <value>Documentation should use the term 'unique identifier' instead of 'guid'</value>
  </data>
  <data name="MiKo_2204_CodeFixTitle" xml:space="preserve">
    <value>Use &lt;list&gt; to list items</value>
  </data>
  <data name="MiKo_2204_Description" xml:space="preserve">
    <value>The XML documentation should use the &lt;list&gt; tag if items get enumerated. It should not use terms such as 1.), 2.) etc. directly.
This is because IntelliSense or any XML documentation tool are not aware of such terms and therefore the comment will become strangely formatted and hard to read.</value>
  </data>
  <data name="MiKo_2204_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/xmldoc/list</value>
  </data>
  <data name="MiKo_2204_MessageFormat" xml:space="preserve">
    <value>Use &lt;list&gt; to list items in documentation</value>
  </data>
  <data name="MiKo_2204_Title" xml:space="preserve">
    <value>Documentation should use &lt;list&gt; for enumerations</value>
  </data>
  <data name="MiKo_2205_Description" xml:space="preserve">
    <value>The XML documentation should use the &lt;note&gt; tag to mark important information. It should not use terms such as 'Important' or 'Attention' directly.
This is because XML documentation tools are aware of &lt;note&gt; and can format the information in a special way.</value>
  </data>
  <data name="MiKo_2205_MessageFormat" xml:space="preserve">
    <value>Use &lt;note&gt; for important information in documentation</value>
  </data>
  <data name="MiKo_2205_Title" xml:space="preserve">
    <value>Documentation should use &lt;note&gt; for important information</value>
  </data>
  <data name="MiKo_2206_Description" xml:space="preserve">
    <value>The documentation should not use the term 'flag' which is often used to describe a boolean value. Instead, the documentation should be re-phrased so that the term is no longer necessary.</value>
  </data>
  <data name="MiKo_2206_MessageFormat" xml:space="preserve">
    <value>Remove '{1}' from documentation</value>
  </data>
  <data name="MiKo_2206_Title" xml:space="preserve">
    <value>Documentation should not use the term 'flag'</value>
  </data>
  <data name="MiKo_2207_Description" xml:space="preserve">
    <value>The &lt;summary&gt; documentation shall be descriptive and short as its intent is to give a short overview about a functionality.
More detailed information should be placed inside a &lt;remarks&gt; section.</value>
  </data>
  <data name="MiKo_2207_MessageFormat" xml:space="preserve">
    <value>&lt;summary&gt; is too long, use &lt;remarks&gt; section for all the details</value>
  </data>
  <data name="MiKo_2207_Title" xml:space="preserve">
    <value>&lt;summary&gt; documentation shall be short</value>
  </data>
  <data name="MiKo_2208_Description" xml:space="preserve">
    <value>The documentation should use a more meaningful description than the phrase 'an instance of'.
By having a more concrete description it makes it easier for a developer to understand the meaning.</value>
  </data>
  <data name="MiKo_2208_MessageFormat" xml:space="preserve">
    <value>Use a better description than '{1}'</value>
  </data>
  <data name="MiKo_2208_Title" xml:space="preserve">
    <value>Documentation should not use the term 'an instance of'</value>
  </data>
  <data name="MiKo_2209_CodeFixTitle" xml:space="preserve">
    <value>Remove '..' from documentation</value>
  </data>
  <data name="MiKo_2209_Description" xml:space="preserve">
    <value>XML documentation is intended for other developers. It shall contain all the information that is important for them in a way that they can easily read and understand. Typos or other kinds of strange comments however are harder to understand. Thus, such things need to be avoided to not confuse the developers.</value>
  </data>
  <data name="MiKo_2209_MessageFormat" xml:space="preserve">
    <value>Remove '..' from documentation</value>
  </data>
  <data name="MiKo_2209_Title" xml:space="preserve">
    <value>Do not use double periods in documentation</value>
  </data>
  <data name="MiKo_2210_CodeFixTitle" xml:space="preserve">
    <value>Change 'info' into 'information'</value>
  </data>
  <data name="MiKo_2210_Description" xml:space="preserve">
    <value>The XML documentation should not use the abbreviation 'info'. Instead, it should clearly document that this is an information. Hence, it should use the term 'information' instead.</value>
  </data>
  <data name="MiKo_2210_MessageFormat" xml:space="preserve">
    <value>Use 'information' instead of 'info'</value>
  </data>
  <data name="MiKo_2210_Title" xml:space="preserve">
    <value>Documentation should use the term 'information' instead of 'info'</value>
  </data>
  <data name="MiKo_2211_CodeFixTitle" xml:space="preserve">
    <value>Move remarks comment into summary</value>
  </data>
  <data name="MiKo_2211_Description" xml:space="preserve">
    <value>Unfortunately, tools such as Sandcastle cannot handle &lt;remarks&gt; sections on enum members. The resulting output (CHM, HTML, ...) does not contain any Remarks section.

As developers may use the HTML/CHM version only when working with 3rd party frameworks, the information of the &lt;remarks&gt; section is typically not available to them.

Hence, to provide them with all the information they need, the information should be placed inside the &lt;summary&gt; section.</value>
  </data>
  <data name="MiKo_2211_MessageFormat" xml:space="preserve">
    <value>Use &lt;summary&gt; instead of &lt;remarks&gt;</value>
  </data>
  <data name="MiKo_2211_Title" xml:space="preserve">
    <value>Enum members should not have &lt;remarks&gt; sections</value>
  </data>
  <data name="MiKo_2212_CodeFixTitle" xml:space="preserve">
    <value>Change 'was not successful' to 'failed'</value>
  </data>
  <data name="MiKo_2212_Description" xml:space="preserve">
    <value>To shorten documentation - and still be to the point - the documentation should use the phrase 'failed' instead of 'was not succesful'.</value>
  </data>
  <data name="MiKo_2212_MessageFormat" xml:space="preserve">
    <value>Use 'failed' instead of 'was not successful'</value>
  </data>
  <data name="MiKo_2212_Title" xml:space="preserve">
    <value>Documentation should use the phrase 'failed' instead of 'was not successful'</value>
  </data>
  <data name="MiKo_2213_CodeFixTitle" xml:space="preserve">
    <value>Change "n't" to " not"</value>
  </data>
  <data name="MiKo_2213_Description" xml:space="preserve">
    <value>It may happen to read over and not recognize a contradiction. This then leads to unintentional errors.
It would therefore be better to clearly highlight the contradiction.</value>
  </data>
  <data name="MiKo_2213_MessageFormat" xml:space="preserve">
    <value>Do not use contradiction "n't"</value>
  </data>
  <data name="MiKo_2213_Title" xml:space="preserve">
    <value>Documentation should not use the contradiction "n't"</value>
  </data>
  <data name="MiKo_2214_CodeFixTitle" xml:space="preserve">
    <value>Replace empty line with &lt;para/&gt;</value>
  </data>
  <data name="MiKo_2214_Description" xml:space="preserve">
    <value>The documentation should not contain empty lines. Developers tend to use them when they write paragraphs.
However, in the generated documentation (eg. for IntelliSense) those empty lines are simply ignored, get removed and the text becomes quite dense.
In contrast, using the &lt;para&gt; tags avoids that situation as the &lt;para&gt; tag is intended to be used to mark paragraphs.</value>
  </data>
  <data name="MiKo_2214_MessageFormat" xml:space="preserve">
    <value>Replace empty line with &lt;para/&gt;</value>
  </data>
  <data name="MiKo_2214_Title" xml:space="preserve">
    <value>Documentation should not contain empty lines</value>
  </data>
  <data name="MiKo_2215_Description" xml:space="preserve">
    <value>Sentences containing up to 15 words are most effective in terms of content and descriptiveness. Longer sentences are hard to read any may boring out readers.</value>
  </data>
  <data name="MiKo_2215_MessageFormat" xml:space="preserve">
    <value>Shorten sentences to contain up to 15 words each</value>
  </data>
  <data name="MiKo_2215_Title" xml:space="preserve">
    <value>Sentences in documentation shall be short</value>
  </data>
  <data name="MiKo_2216_CodeFixTitle" xml:space="preserve">
    <value>Change &lt;param&gt; to &lt;paramref&gt;</value>
  </data>
  <data name="MiKo_2216_Description" xml:space="preserve">
    <value>The &lt;param&gt; tag is used to describe parameters while the &lt;paramref&gt; tag gives you a way to indicate that a word in the code comments refers to a parameter.
So if you want to reference a parameter inside e.g. the &lt;summary&gt; or &lt;remarks&gt; section, you should use the &lt;paramref&gt; tag.</value>
  </data>
  <data name="MiKo_2216_MessageFormat" xml:space="preserve">
    <value>Do use &lt;paramref&gt; instead of &lt;param&gt;</value>
  </data>
  <data name="MiKo_2216_Title" xml:space="preserve">
    <value>Do use &lt;paramref&gt; instead of &lt;param&gt; to reference parameters</value>
  </data>
  <data name="MiKo_2217_CodeFixTitle" xml:space="preserve">
    <value>Fix '&lt;list&gt;'</value>
  </data>
  <data name="MiKo_2217_Description" xml:space="preserve">
    <value>The documentation of a &lt;list&gt; is a little bit ambiguous.
There are 3 types of lists: 'number', 'bullet' and 'table'. Only the 'table' can have a single &lt;listheader&gt; and multiple &lt;item&gt; entries, the others have only &lt;item&gt; entries.

For a 'table', each &lt;listheader&gt; and &lt;item&gt;s can contain either a single but optional &lt;term&gt; and a single required &lt;description&gt;, or multiple &lt;term&gt; entries.
For a 'bullet' or 'number' list, each &lt;item&gt; can contain a single but optional &lt;term&gt; and a single required &lt;description&gt;.

Any &lt;item&gt; should never contain multiple &lt;description&gt; entries.</value>
  </data>
  <data name="MiKo_2217_HelpLinkUri" xml:space="preserve">
    <value>http://www.blackwasp.co.uk/DocumentationLists.aspx</value>
  </data>
  <data name="MiKo_2217_MessageArgument_MissingDescription" xml:space="preserve">
    <value>&lt;description&gt; is missing</value>
  </data>
  <data name="MiKo_2217_MessageArgument_MissingTermOrDescription" xml:space="preserve">
    <value>&lt;description&gt; or &lt;term&gt; is missing</value>
  </data>
  <data name="MiKo_2217_MessageArgument_NoHeaderAllowed" xml:space="preserve">
    <value>&lt;listheader&gt; is not allowed for this type of &lt;list&gt;</value>
  </data>
  <data name="MiKo_2217_MessageArgument_OnlySingleDescriptionAllowed" xml:space="preserve">
    <value>&lt;description&gt; is not allowed to occur multiple times for this type of &lt;list&gt;</value>
  </data>
  <data name="MiKo_2217_MessageArgument_OnlySingleTermAllowed" xml:space="preserve">
    <value>&lt;term&gt; is not allowed to occur multiple times for this type of &lt;list&gt;</value>
  </data>
  <data name="MiKo_2217_MessageArgument_UnknownTypeSpecified" xml:space="preserve">
    <value>The 'type' attribute contains the unknown type {0}</value>
  </data>
  <data name="MiKo_2217_MessageFormat" xml:space="preserve">
    <value>Use &lt;list&gt; properly: {1}</value>
  </data>
  <data name="MiKo_2217_Title" xml:space="preserve">
    <value>&lt;list&gt; documentation is done properly</value>
  </data>
  <data name="MiKo_2218_CodeFixTitle" xml:space="preserve">
    <value>Shorten term</value>
  </data>
  <data name="MiKo_2218_Description" xml:space="preserve">
    <value>Terms such as 'that is used to' or 'which shall be used to' are simply bloated and should be shortened to the equivalent term 'to'.</value>
  </data>
  <data name="MiKo_2218_MessageFormat" xml:space="preserve">
    <value>Replace '{1}' with '{2}'</value>
  </data>
  <data name="MiKo_2218_Title" xml:space="preserve">
    <value>Documentation should use shorter term 'to' instead of longer term '... used to'</value>
  </data>
  <data name="MiKo_2300_Description" xml:space="preserve">
    <value>Comments should explain the deeper reasons behind the code to understand why the code is written in that way.
They should not describe how it is achieved because that's what the code is for.</value>
  </data>
  <data name="MiKo_2300_MessageFormat" xml:space="preserve">
    <value>Remove comment or describe why exactly the code is the way it is</value>
  </data>
  <data name="MiKo_2300_Title" xml:space="preserve">
    <value>Comments should explain the 'Why' and not the 'How'</value>
  </data>
  <data name="MiKo_2301_CodeFixTitle" xml:space="preserve">
    <value>Remove obvious AAA comment</value>
  </data>
  <data name="MiKo_2301_Description" xml:space="preserve">
    <value>Inside tests that follow the Arrange/Act/Assert style, the comments '// arrange', '// act' and '// assert' are obvious and provide no benefit. Therefore, they can be removed.</value>
  </data>
  <data name="MiKo_2301_MessageFormat" xml:space="preserve">
    <value>Remove obvious AAA comment</value>
  </data>
  <data name="MiKo_2301_Title" xml:space="preserve">
    <value>Do not use obvious comments in AAA-Tests</value>
  </data>
  <data name="MiKo_2302_Description" xml:space="preserve">
    <value>The longer code is kept that is commented out, the much likelier the code cannot compile anymore.
As code should be commited in to Source Control Systems, developers can use the SCS's history and go back to an older version that still contains the code. So there is no need to keep the code commented out.</value>
  </data>
  <data name="MiKo_2302_MessageFormat" xml:space="preserve">
    <value>Remove commented out code</value>
  </data>
  <data name="MiKo_2302_Title" xml:space="preserve">
    <value>Do not keep code that is commented out</value>
  </data>
  <data name="MiKo_2303_CodeFixTitle" xml:space="preserve">
    <value>Remove ending period from comment</value>
  </data>
  <data name="MiKo_2303_Description" xml:space="preserve">
    <value>In contrast to API documentation inline comments are intended to team members. They should contain the important information in a short way, so they should not be complete sentences.

This rule contradicts rule MiKo_2306.</value>
  </data>
  <data name="MiKo_2303_MessageFormat" xml:space="preserve">
    <value>Do not end comment with period</value>
  </data>
  <data name="MiKo_2303_Title" xml:space="preserve">
    <value>Do not end comments with a period</value>
  </data>
  <data name="MiKo_2304_Description" xml:space="preserve">
    <value>Comments should explain the code and the reasons behind, they should not question things.
If it question things, then the reasons behind are still unclear. This makes it (in the long run) hard to maintain because such questions don't get answered (otherwise, the comment would have been gone meanwhile).</value>
  </data>
  <data name="MiKo_2304_MessageFormat" xml:space="preserve">
    <value>Comment should explain, not ask</value>
  </data>
  <data name="MiKo_2304_Title" xml:space="preserve">
    <value>Do not formulate comments as questions</value>
  </data>
  <data name="MiKo_2305_CodeFixTitle" xml:space="preserve">
    <value>Remove '..' from comment</value>
  </data>
  <data name="MiKo_2305_Description" xml:space="preserve">
    <value>In contrast to API documentation inline comments are intended for team members. They should contain the important information in a short way, so they should not be complete sentences.</value>
  </data>
  <data name="MiKo_2305_MessageFormat" xml:space="preserve">
    <value>Remove '..' from comment</value>
  </data>
  <data name="MiKo_2305_Title" xml:space="preserve">
    <value>Do not use double periods in comments</value>
  </data>
  <data name="MiKo_2306_Description" xml:space="preserve">
    <value>In contrast to API documentation inline comments are intended to team members. They should contain the important information in a short way, so they should be complete sentences.

This rule contradicts rule MiKo_2303.</value>
  </data>
  <data name="MiKo_2306_MessageFormat" xml:space="preserve">
    <value>Do end comment with period</value>
  </data>
  <data name="MiKo_2306_Title" xml:space="preserve">
    <value>Do end comments with a period</value>
  </data>
  <data name="MiKo_2307_CodeFixTitle" xml:space="preserve">
    <value>Replace with 'failed'</value>
  </data>
  <data name="MiKo_2307_Description" xml:space="preserve">
    <value>To shorten comments - and still be to the point - comments should use the phrase 'failed' instead of 'was not successful'.</value>
  </data>
  <data name="MiKo_2307_MessageFormat" xml:space="preserve">
    <value>Use 'failed' instead of 'was not successful'</value>
  </data>
  <data name="MiKo_2307_Title" xml:space="preserve">
    <value>Comments should use the phrase 'failed' instead of 'was not successful'</value>
  </data>
  <data name="MiKo_2308_CodeFixTitle" xml:space="preserve">
    <value>Place comment before code</value>
  </data>
  <data name="MiKo_2308_Description" xml:space="preserve">
    <value>Most times, a comment describes something that is related to an operation.
That's why the comment should not be placed after the operation, but before. So the reader can easily associate the comment with the operation and does not need to guess if both are related or not.</value>
  </data>
  <data name="MiKo_2308_MessageFormat" xml:space="preserve">
    <value>Place comment before code</value>
  </data>
  <data name="MiKo_2308_Title" xml:space="preserve">
    <value>Do not place comment on single line before closing brace but after code</value>
  </data>
  <data name="MiKo_2309_CodeFixTitle" xml:space="preserve">
    <value>Change "n't" to " not"</value>
  </data>
  <data name="MiKo_2309_Description" xml:space="preserve">
    <value>It may happen to read over and not recognize a contradiction. This then leads to unintentional errors.
It would therefore be better to clearly highlight the contradiction.</value>
  </data>
  <data name="MiKo_2309_MessageFormat" xml:space="preserve">
    <value>Do not use contradiction "n't"</value>
  </data>
  <data name="MiKo_2309_Title" xml:space="preserve">
    <value>Comments should not use the contradiction "n't"</value>
  </data>
  <data name="MiKo_3000_Description" xml:space="preserve">
    <value>If #region shall be used, then any empty #region shall be avoided.
Such empty regions solely clutter the code without providing any benefit at all.</value>
  </data>
  <data name="MiKo_3000_MessageFormat" xml:space="preserve">
    <value>Remove empty {0}</value>
  </data>
  <data name="MiKo_3000_Title" xml:space="preserve">
    <value>Do not use empty regions</value>
  </data>
  <data name="MiKo_3001_Description" xml:space="preserve">
    <value>To ease maintenance, use the pre-defined .NET Framework delegate types such as 'Action', 'Func' or 'Expression' instead of custom delegates.</value>
  </data>
  <data name="MiKo_3001_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/events-and-callbacks</value>
  </data>
  <data name="MiKo_3001_MessageFormat" xml:space="preserve">
    <value>Use 'Action', 'Func' or 'Expression' instead</value>
  </data>
  <data name="MiKo_3001_Title" xml:space="preserve">
    <value>Custom delegates should not be used</value>
  </data>
  <data name="MiKo_3002_Description" xml:space="preserve">
    <value>If a class has too many dependencies, that class is doing too much and does not follow the SRP.</value>
  </data>
  <data name="MiKo_3002_MessageFormat" xml:space="preserve">
    <value>Too many MEF dependencies: {1,4} (allowed are max. {2})</value>
  </data>
  <data name="MiKo_3002_Title" xml:space="preserve">
    <value>Classes should not have too many dependencies</value>
  </data>
  <data name="MiKo_3003_Description" xml:space="preserve">
    <value>To ease usage, events should follow the .NET Framework Guidelines for Event Design.</value>
  </data>
  <data name="MiKo_3003_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/event</value>
  </data>
  <data name="MiKo_3003_MessageFormat" xml:space="preserve">
    <value>Use 'EventHandler' or 'EventHandler&lt;T&gt;' instead</value>
  </data>
  <data name="MiKo_3003_Title" xml:space="preserve">
    <value>Events should follow .NET Framework Guidelines for events</value>
  </data>
  <data name="MiKo_3004_Description" xml:space="preserve">
    <value>EventArgs exist only to raise events and to pass some data that to the listening event handlers.
If the carried event data now changes between the different handlers, the behavior gets unpredictable and a race condition occurs.

To avoid that situation, the properties of EventArgs shall be read-only or only privately settable. If you have to set the event data, provide a method to do so and ensure that the method acts as circuit breaker (that is you can set the data exactly once).</value>
  </data>
  <data name="MiKo_3004_MessageFormat" xml:space="preserve">
    <value>Make setter private or property read-only</value>
  </data>
  <data name="MiKo_3004_Title" xml:space="preserve">
    <value>Property setters of EventArgs shall be private</value>
  </data>
  <data name="MiKo_3005_Description" xml:space="preserve">
    <value>To ease maintenance, methods that are named 'Try' should follow the Trier-Doer-Pattern.

That is they should return a Boolean and have the last parameter as [out] parameter for the result. In the success case the method should return 'true' and provide valid out data; in all other cases the method should return 'false'.</value>
  </data>
  <data name="MiKo_3005_MessageFormat" xml:space="preserve">
    <value>Follow the Trier-Doer-Pattern</value>
  </data>
  <data name="MiKo_3005_Title" xml:space="preserve">
    <value>Methods named 'Try' should follow the Trier-Doer-Pattern</value>
  </data>
  <data name="MiKo_3006_Description" xml:space="preserve">
    <value>To ease maintenance, and being consistent with the .NET Framework classes, 'CancellationToken' parameters should come after all the other parameters of a method.</value>
  </data>
  <data name="MiKo_3006_MessageFormat" xml:space="preserve">
    <value>Place '{0}' as last parameter</value>
  </data>
  <data name="MiKo_3006_Title" xml:space="preserve">
    <value>'CancellationToken' parameter should be last method parameter</value>
  </data>
  <data name="MiKo_3007_Description" xml:space="preserve">
    <value>To ease maintainability and readability, methods should be written using only one single language. Hence LINQ method syntax and declarative query syntax should not be used within the same method.</value>
  </data>
  <data name="MiKo_3007_MessageFormat" xml:space="preserve">
    <value>Do not mix LINQ syntax</value>
  </data>
  <data name="MiKo_3007_Title" xml:space="preserve">
    <value>Do not use LINQ method and declarative query syntax in same method</value>
  </data>
  <data name="MiKo_3008_Description" xml:space="preserve">
    <value>Methods should not return changeable collections such as 'ICollection&lt;T&gt;' because those can be changed from outside. Instead they should return the read-only variants (e.g. 'IReadOnlyCollection&lt;T&gt;').</value>
  </data>
  <data name="MiKo_3008_MessageFormat" xml:space="preserve">
    <value>Use a read-only immutable variant or 'IEnumerable&lt;T&gt;' instead</value>
  </data>
  <data name="MiKo_3008_Title" xml:space="preserve">
    <value>Method should not return collections that can be changed from outside</value>
  </data>
  <data name="MiKo_3009_Description" xml:space="preserve">
    <value>Methods that are invoked by commands should not be lambda expressions as that makes them hard to read, understand and maintain. Instead they should be named methods that have a meaningful name.</value>
  </data>
  <data name="MiKo_3009_MessageFormat" xml:space="preserve">
    <value>Use named method instead</value>
  </data>
  <data name="MiKo_3009_Title" xml:space="preserve">
    <value>Commands should invoke only named methods and no lambda expressions</value>
  </data>
  <data name="MiKo_3010_Description" xml:space="preserve">
    <value>Specific kinds of exceptions are reserved and thrown by the execution engine (CLR) and in most cases indicate a bug.</value>
  </data>
  <data name="MiKo_3010_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/using-standard-exception-types</value>
  </data>
  <data name="MiKo_3010_MessageFormat" xml:space="preserve">
    <value>Do not create a '{0}'</value>
  </data>
  <data name="MiKo_3010_Title" xml:space="preserve">
    <value>Do not create or throw reserved exception types</value>
  </data>
  <data name="MiKo_3011_CodeFixTitle" xml:space="preserve">
    <value>Add 'paramName' parameter</value>
  </data>
  <data name="MiKo_3011_Description" xml:space="preserve">
    <value>Thrown ArgumentExceptions (or its subtypes) should contain the name of the parameter that caused the exception to be thrown.</value>
  </data>
  <data name="MiKo_3011_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/using-standard-exception-types#argumentexception-argumentnullexception-and-argumentoutofrangeexception</value>
  </data>
  <data name="MiKo_3011_MessageFormat" xml:space="preserve">
    <value>Set 'paramName' parameter to {1}</value>
  </data>
  <data name="MiKo_3011_Title" xml:space="preserve">
    <value>Thrown ArgumentExceptions (or its subtypes) shall provide the correct parameter name</value>
  </data>
  <data name="MiKo_3012_CodeFixTitle" xml:space="preserve">
    <value>Provide actual value</value>
  </data>
  <data name="MiKo_3012_Description" xml:space="preserve">
    <value>Thrown ArgumentOutOfRangeExceptions (or its subtypes) should contain the actual value of the parameter that caused the exception to be thrown.</value>
  </data>
  <data name="MiKo_3012_MessageFormat" xml:space="preserve">
    <value>Provide the actual value that causes the exception to be thrown</value>
  </data>
  <data name="MiKo_3012_Title" xml:space="preserve">
    <value>Thrown ArgumentOutOfRangeExceptions (or its subtypes) shall provide the actual value that causes the exception to be thrown</value>
  </data>
  <data name="MiKo_3013_CodeFixTitle" xml:space="preserve">
    <value>Change to 'ArgumentOutOfRangeException'</value>
  </data>
  <data name="MiKo_3013_Description" xml:space="preserve">
    <value>The 'default' clause in 'switch' statements should throw an ArgumentOutOfRangeException (or subtype) to indicate that the given argument is out of range, but no ArgumentException.</value>
  </data>
  <data name="MiKo_3013_MessageFormat" xml:space="preserve">
    <value>Throw an 'ArgumentOutOfRangeException' instead</value>
  </data>
  <data name="MiKo_3013_Title" xml:space="preserve">
    <value>The 'default' clause in 'switch' statements should throw an ArgumentOutOfRangeException (or subtype), but no ArgumentException</value>
  </data>
  <data name="MiKo_3014_CodeFixTitle" xml:space="preserve">
    <value>Add a default reason</value>
  </data>
  <data name="MiKo_3014_Description" xml:space="preserve">
    <value>To ease maintenance, a thrown InvalidOperationException, NotImplementedException or NotSupportedException should have a reason that explains the circumstances why the exception has been thrown and - ideally - how to solve the situation.</value>
  </data>
  <data name="MiKo_3014_MessageFormat" xml:space="preserve">
    <value>Provide a reason for the thrown '{0}'</value>
  </data>
  <data name="MiKo_3014_Title" xml:space="preserve">
    <value>InvalidOperationException, NotImplementedException and NotSupportedException should have a reason as message</value>
  </data>
  <data name="MiKo_3015_CodeFixTitle" xml:space="preserve">
    <value>Change to 'InvalidOperationException'</value>
  </data>
  <data name="MiKo_3015_Description" xml:space="preserve">
    <value>ArgumentExceptions (or its subtypes) should not be thrown by parameterless methods.
If the method call does not have any argument or if the failure does not involve the arguments themselves, then InvalidOperationException should be used.</value>
  </data>
  <data name="MiKo_3015_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/using-standard-exception-types</value>
  </data>
  <data name="MiKo_3015_MessageFormat" xml:space="preserve">
    <value>Throw an 'InvalidOperationException' instead</value>
  </data>
  <data name="MiKo_3015_Title" xml:space="preserve">
    <value>Throw InvalidOperationExceptions (instead of ArgumentExceptions or its subtypes) to indicate inappropriate states of parameterless methods</value>
  </data>
  <data name="MiKo_3016_CodeFixTitle" xml:space="preserve">
    <value>Change to 'ArgumentException' or 'InvalidOperationException'</value>
  </data>
  <data name="MiKo_3016_Description" xml:space="preserve">
    <value>ArgumentNullExceptions should not be thrown for values of properties that are returned by parameters.
If you want to indicate a problem for the parameter, throw an ArgumentException instead.
If it's no issue of the parameter itself, throw an InvalidOperationException instead.</value>
  </data>
  <data name="MiKo_3016_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/using-standard-exception-types</value>
  </data>
  <data name="MiKo_3016_MessageFormat" xml:space="preserve">
    <value>Throw an 'ArgumentException' or 'InvalidOperationException' instead</value>
  </data>
  <data name="MiKo_3016_Title" xml:space="preserve">
    <value>Do not throw ArgumentNullException for inappropriate states of property return values</value>
  </data>
  <data name="MiKo_3017_CodeFixTitle" xml:space="preserve">
    <value>Add inner exception</value>
  </data>
  <data name="MiKo_3017_Description" xml:space="preserve">
    <value>If an exception gets caught and a new exception gets thrown, it's much easier if the new exception contains the caught one as inner exception.</value>
  </data>
  <data name="MiKo_3017_MessageFormat" xml:space="preserve">
    <value>Provide exception as inner exception</value>
  </data>
  <data name="MiKo_3017_Title" xml:space="preserve">
    <value>Do not swallow exceptions when throwing new exceptions</value>
  </data>
  <data name="MiKo_3018_Description" xml:space="preserve">
    <value>Already disposed instances of disposable types should indicate that they are disposed when invoking methods on them. That makes it easier to spot bugs because the user code should never access already disposed types.</value>
  </data>
  <data name="MiKo_3018_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose</value>
  </data>
  <data name="MiKo_3018_MessageFormat" xml:space="preserve">
    <value>Throw ObjectDisposedException if disposed</value>
  </data>
  <data name="MiKo_3018_Title" xml:space="preserve">
    <value>Throw ObjectDisposedExceptions on publicly visible methods of disposable types</value>
  </data>
  <data name="MiKo_3020_CodeFixTitle" xml:space="preserve">
    <value>Use 'Task.CompletedTask'</value>
  </data>
  <data name="MiKo_3020_Description" xml:space="preserve">
    <value>For performance reasons it's better to use 'Task.CompletedTask' instead of 'Task.FromResult()' as the returned task is internally cached.</value>
  </data>
  <data name="MiKo_3020_MessageFormat" xml:space="preserve">
    <value>Use 'Task.CompletedTask' instead</value>
  </data>
  <data name="MiKo_3020_Title" xml:space="preserve">
    <value>Use 'Task.CompletedTask' instead of 'Task.FromResult'</value>
  </data>
  <data name="MiKo_3021_Description" xml:space="preserve">
    <value>If you use 'Task.Run' to return a Task because a method is a long-running operation, then this most probably means that you've doing something wrong. If you have a long-running operation, use 'Task.Run' to call it.</value>
  </data>
  <data name="MiKo_3021_HelpLinkUri" xml:space="preserve">
    <value>https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html</value>
  </data>
  <data name="MiKo_3021_MessageFormat" xml:space="preserve">
    <value>Use '{0}' to invoke method '{1}', but not inside</value>
  </data>
  <data name="MiKo_3021_Title" xml:space="preserve">
    <value>Do not use 'Task.Run' in the implementation</value>
  </data>
  <data name="MiKo_3022_Description" xml:space="preserve">
    <value>If a method returns Task&lt;IEnumerable&gt; or Task&lt;IEnumerable&lt;T&gt;&gt;, then it is likely that the enumerable is not evaluated until it is accessed in a foreach or Linq call.
That accessor likely is another thread (e.g. the main thread) which contradicts the whole idea of returning a dedicated task.</value>
  </data>
  <data name="MiKo_3022_MessageFormat" xml:space="preserve">
    <value>Do not return '{1}'</value>
  </data>
  <data name="MiKo_3022_Title" xml:space="preserve">
    <value>Do not return Task&lt;IEnumerable&gt; or Task&lt;IEnumerable&lt;T&gt;&gt;</value>
  </data>
  <data name="MiKo_3023_Description" xml:space="preserve">
    <value>A 'CancellationTokenSource' should not be passed around. Instead, the 'CancellationToken' should be passed around to propagate notifications that operations should be canceled.</value>
  </data>
  <data name="MiKo_3023_MessageFormat" xml:space="preserve">
    <value>Use a '{1}' instead</value>
  </data>
  <data name="MiKo_3023_Title" xml:space="preserve">
    <value>Do not use 'CancellationTokenSource' as parameter</value>
  </data>
  <data name="MiKo_3024_Description" xml:space="preserve">
    <value>[ref] allows to change the storage location of the variable it is declared on. This allows to re-assign values to an already existing variable and therefore altering it.
In case of reference types the altered variable is an altered object reference, thus all callees that access the altered variable later on get the changed one (very similar to an out parameter).

In most cases this is not wanted. The object reference shall be the same, only the object shall be altered.</value>
  </data>
  <data name="MiKo_3024_MessageFormat" xml:space="preserve">
    <value>Do not use 'ref'</value>
  </data>
  <data name="MiKo_3024_Title" xml:space="preserve">
    <value>Do not use the [ref] keyword on reference parameters</value>
  </data>
  <data name="MiKo_3025_Description" xml:space="preserve">
    <value>Method parameters should be considered as read-only. They should not be re-assigned to other values. If you need them to have another value, use a local variable instead.</value>
  </data>
  <data name="MiKo_3025_MessageFormat" xml:space="preserve">
    <value>Do not re-assign '{0}'</value>
  </data>
  <data name="MiKo_3025_Title" xml:space="preserve">
    <value>Do not re-assign method parameters</value>
  </data>
  <data name="MiKo_3026_Description" xml:space="preserve">
    <value>Unused parameters are not needed and should be removed as they solely clutter the code base without providing any benefit at all.</value>
  </data>
  <data name="MiKo_3026_MessageFormat" xml:space="preserve">
    <value>Parameter is not used and can be safely removed</value>
  </data>
  <data name="MiKo_3026_Title" xml:space="preserve">
    <value>Unused parameters should be removed</value>
  </data>
  <data name="MiKo_3027_Description" xml:space="preserve">
    <value>Marking parameters for future usage leads to a bad design. It is unclear whether the parameter will ever be used. It is also unclear whether the type of the parameter will match future needs. In future, you can always override methods and add new parameters.</value>
  </data>
  <data name="MiKo_3027_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/parameter-design</value>
  </data>
  <data name="MiKo_3027_MessageFormat" xml:space="preserve">
    <value>Do not reserve '{0}' for future usage</value>
  </data>
  <data name="MiKo_3027_Title" xml:space="preserve">
    <value>Parameters should not be marked to be reserved for future usage</value>
  </data>
  <data name="MiKo_3028_Description" xml:space="preserve">
    <value>If a collection shall be cleared, then 'Clear()' should be invoked. Assigning 'null' to a parameter will not do anything here because the parameter is only a copy (reference) of the original parameter.</value>
  </data>
  <data name="MiKo_3028_MessageFormat" xml:space="preserve">
    <value>Do not assign null (is cleanup wanted here?)</value>
  </data>
  <data name="MiKo_3028_Title" xml:space="preserve">
    <value>Do not assign null to lambda parameters</value>
  </data>
  <data name="MiKo_3030_Description" xml:space="preserve">
    <value>To ease maintenance, methods assume as little as possible about the structure or properties of objects they use. They should only work with objects they get directly, but they should not reach through them to access other objects and their services.</value>
  </data>
  <data name="MiKo_3030_HelpLinkUri" xml:space="preserve">
    <value>https://en.wikipedia.org/wiki/Law_of_Demeter</value>
  </data>
  <data name="MiKo_3030_MessageFormat" xml:space="preserve">
    <value>Avoid to violate the Law of Demeter</value>
  </data>
  <data name="MiKo_3030_Title" xml:space="preserve">
    <value>Methods should follow the Law of Demeter</value>
  </data>
  <data name="MiKo_3031_Description" xml:space="preserve">
    <value>The ICloneable.Clone() method does not define whether a deep or a swallow copy shall be returned.

As that is not defined, there is no guarantee how it gets implemented, and - because of that - it simply cannot be used as there is a huge difference between a deep and a swallow copy.</value>
  </data>
  <data name="MiKo_3031_MessageFormat" xml:space="preserve">
    <value>Do not implement 'ICloneable.Clone()'</value>
  </data>
  <data name="MiKo_3031_Title" xml:space="preserve">
    <value>ICloneable.Clone() should not be implemented</value>
  </data>
  <data name="MiKo_3032_CodeFixTitle" xml:space="preserve">
    <value>Use 'nameof'</value>
  </data>
  <data name="MiKo_3032_Description" xml:space="preserve">
    <value>Property names that are passed into the 'PropertyChangedEventArgs' constructors shall be provided via the 'nameof' operator. This eases refactorings.</value>
  </data>
  <data name="MiKo_3032_MessageFormat" xml:space="preserve">
    <value>Use '{1}' instead</value>
  </data>
  <data name="MiKo_3032_Title" xml:space="preserve">
    <value>Use 'nameof' instead of Cinch for names of properties for created 'PropertyChangedEventArgs' instances</value>
  </data>
  <data name="MiKo_3033_CodeFixTitle" xml:space="preserve">
    <value>Use 'nameof'</value>
  </data>
  <data name="MiKo_3033_Description" xml:space="preserve">
    <value>Property names that are passed into the 'PropertyChangingEventArgs' and 'PropertyChangedEventArgs' constructors shall be provided via the 'nameof' operator. This prevents typos or non-existing invalid names and eases refactorings.</value>
  </data>
  <data name="MiKo_3033_MessageFormat" xml:space="preserve">
    <value>Use 'nameof'</value>
  </data>
  <data name="MiKo_3033_Title" xml:space="preserve">
    <value>Use 'nameof' for names of properties for created 'PropertyChangingEventArgs' and 'PropertyChangedEventArgs' instances</value>
  </data>
  <data name="MiKo_3034_CodeFixTitle" xml:space="preserve">
    <value>Apply [CallerMemberName]</value>
  </data>
  <data name="MiKo_3034_Description" xml:space="preserve">
    <value>A method that raises the PropertyChanging or PropertyChanged events should use the [CallerMemberNameAttribute] to specify the name of the property automatically.</value>
  </data>
  <data name="MiKo_3034_MessageFormat" xml:space="preserve">
    <value>Apply [CallerMemberName] attribute</value>
  </data>
  <data name="MiKo_3034_Title" xml:space="preserve">
    <value>PropertyChanged event raiser shall use [CallerMemberName] attribute</value>
  </data>
  <data name="MiKo_3035_Description" xml:space="preserve">
    <value>'WaitOne' methods are normally invoked to wait for a specific situation to occur. If the wait is forever, deadlocks or livelocks can occur. To avoid that, allow the wait to time out b providing a 'TimeSpan' to 'WaitOne'.</value>
  </data>
  <data name="MiKo_3035_MessageFormat" xml:space="preserve">
    <value>Provide a timeout value</value>
  </data>
  <data name="MiKo_3035_Title" xml:space="preserve">
    <value>Do not invoke 'WaitOne' methods without timeouts</value>
  </data>
  <data name="MiKo_3036_Description" xml:space="preserve">
    <value>The 'TimeSpan' .NET struct contains a lot of constructors having different amounts of parameters. Those constructor invocations are hard to read. As the struct also provides static factory methods such as 'FromMinutes' or 'FromDays', these should be preferred. They are much easier to read and more explicit.

Please note:
It would be even better to use extension methods such as 'Minutes()' or 'Days()' that would allow a more natural usage, such as ' var x = 5.Days(); '.</value>
  </data>
  <data name="MiKo_3036_MessageFormat" xml:space="preserve">
    <value>Use factory or extension method instead</value>
  </data>
  <data name="MiKo_3036_Title" xml:space="preserve">
    <value>Prefer to use 'TimeSpan' factory methods instead of constructors</value>
  </data>
  <data name="MiKo_3037_Description" xml:space="preserve">
    <value>Classes may provide methods such as WaitForExit, WaitOne, ... that have a parameter that is of type int. That parameter is used to specify a timeout, but - as it is a 'magic' number - it is hard to find out the exact amount of time just from reading the number (is it milliseconds, seconds, ... ?)
So to ease maintenance, the number should not be hard-coded. Most times a TimeSpan an be used instead that eases reading a lot.


Please note:
It would be even better to use extension methods such as 'Minutes()' or 'Days()' that would allow a more natural usage, such as ' xyz.WaitForExit(5.Days()); '.</value>
  </data>
  <data name="MiKo_3037_MessageFormat" xml:space="preserve">
    <value>Do not use magic number</value>
  </data>
  <data name="MiKo_3037_Title" xml:space="preserve">
    <value>Do not use magic numbers for timeouts</value>
  </data>
  <data name="MiKo_3038_Description" xml:space="preserve">
    <value>Hard-coded numbers are difficult to understand why they are exactly as they are. So they are kind of 'magic' numbers.
To ease maintenance, such numbers should not be hard-coded - instead they should be defined as constants.</value>
  </data>
  <data name="MiKo_3038_MessageFormat" xml:space="preserve">
    <value>Introduce constant for magic number {1}</value>
  </data>
  <data name="MiKo_3038_Title" xml:space="preserve">
    <value>Do not use magic numbers</value>
  </data>
  <data name="MiKo_3039_Description" xml:space="preserve">
    <value>Properties that use Linq internally most probably behave differently when being accessed later on or multiple times. As the idea of properties is to be able to access fields (with some safety checks in place), that contradicts the intention of being a property and lead to all sorts of unwanted side-effects.
Such properties should be methods instead to make it clear that they behave differently between calls.</value>
  </data>
  <data name="MiKo_3039_MessageFormat" xml:space="preserve">
    <value>Do not use '{1}' inside property</value>
  </data>
  <data name="MiKo_3039_Title" xml:space="preserve">
    <value>Properties should not use Linq or yield</value>
  </data>
  <data name="MiKo_3040_Description" xml:space="preserve">
    <value>To ease maintenance and increase readability, do not use Booleans unless you are absolutely sure there will never be a need for more than two values. Instead, use an Enum.</value>
  </data>
  <data name="MiKo_3040_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/parameter-design</value>
  </data>
  <data name="MiKo_3040_MessageFormat" xml:space="preserve">
    <value>Use an Enum instead</value>
  </data>
  <data name="MiKo_3040_Title" xml:space="preserve">
    <value>Do not use Booleans unless you are absolutely sure that you will never ever need more than 2 values</value>
  </data>
  <data name="MiKo_3041_Description" xml:space="preserve">
    <value>EventArgs should not use delegates such as 'Action' or 'Func' because the callee needs to know exactly how the delegate behaves.
Failures inside the delegate(s) are really hard to tackle down because an exception gets thrown at a completely unrelated area.</value>
  </data>
  <data name="MiKo_3041_MessageFormat" xml:space="preserve">
    <value>Do not use a delegate</value>
  </data>
  <data name="MiKo_3041_Title" xml:space="preserve">
    <value>EventArgs shall not use delegates</value>
  </data>
  <data name="MiKo_3042_Description" xml:space="preserve">
    <value>EventArgs are by themselves contracts. Therefore, they should not implement any additional interface.</value>
  </data>
  <data name="MiKo_3042_MessageFormat" xml:space="preserve">
    <value>Do not implement interface</value>
  </data>
  <data name="MiKo_3042_Title" xml:space="preserve">
    <value>EventArgs shall not implement interfaces</value>
  </data>
  <data name="MiKo_3043_CodeFixTitle" xml:space="preserve">
    <value>Use 'nameof'</value>
  </data>
  <data name="MiKo_3043_Description" xml:space="preserve">
    <value>The names of events that are (de-)registered on the WeakEventManager shall be provided via 'nameof' operator. This prevents typos or non-existing invalid names and eases refactorings.</value>
  </data>
  <data name="MiKo_3043_MessageFormat" xml:space="preserve">
    <value>Use 'nameof'</value>
  </data>
  <data name="MiKo_3043_Title" xml:space="preserve">
    <value>Use 'nameof' for WeakEventManager event (de-)registrations</value>
  </data>
  <data name="MiKo_3044_CodeFixTitle" xml:space="preserve">
    <value>Use 'nameof'</value>
  </data>
  <data name="MiKo_3044_Description" xml:space="preserve">
    <value>Property names that are provided by the 'PropertyChangingEventArgs' and 'PropertyChangedEventArgs' shall be compared via the 'nameof' operator. This prevents typos or non-existing invalid names and eases refactorings.</value>
  </data>
  <data name="MiKo_3044_MessageFormat" xml:space="preserve">
    <value>Use 'nameof'</value>
  </data>
  <data name="MiKo_3044_Title" xml:space="preserve">
    <value>Use 'nameof' to compare property names of 'PropertyChangingEventArgs' and 'PropertyChangedEventArgs'</value>
  </data>
  <data name="MiKo_3047_CodeFixTitle" xml:space="preserve">
    <value>Use 'nameof'</value>
  </data>
  <data name="MiKo_3047_Description" xml:space="preserve">
    <value>To prevent typos, any applied [ContentProperty] attribute shall use 'nameof' to define the property.</value>
  </data>
  <data name="MiKo_3047_MessageFormat" xml:space="preserve">
    <value>Use 'nameof'</value>
  </data>
  <data name="MiKo_3047_Title" xml:space="preserve">
    <value>Use 'nameof' for applied [ContentProperty] attributes</value>
  </data>
  <data name="MiKo_3048_Description" xml:space="preserve">
    <value>To indicate to development tools the data types involved in a conversion, it is a good practice to decorate implementations of the IValueConverter interface with the ValueConversionAttribute attribute.</value>
  </data>
  <data name="MiKo_3048_MessageFormat" xml:space="preserve">
    <value>Apply the [ValueConversion] attribute</value>
  </data>
  <data name="MiKo_3048_Title" xml:space="preserve">
    <value>ValueConverters shall have the [ValueConversion] attribute applied</value>
  </data>
  <data name="MiKo_3049_Description" xml:space="preserve">
    <value>When working with enums in C#, it is sometimes necessary to get a string description of the value associated with the enum. To achieve that, the 'System.ComponentModel.DescriptionAttribute' can be used.</value>
  </data>
  <data name="MiKo_3049_MessageFormat" xml:space="preserve">
    <value>Apply a [Description] attribute with a proper description</value>
  </data>
  <data name="MiKo_3049_Title" xml:space="preserve">
    <value>Enum members shall have the [Description] attribute applied</value>
  </data>
  <data name="MiKo_3050_CodeFixTitle" xml:space="preserve">
    <value>Make DependencyProperty 'public static readonly'</value>
  </data>
  <data name="MiKo_3050_Description" xml:space="preserve">
    <value>Fields that are the back of a DependencyProperty should be made 'public static readonly' to allow the .NET framework and other clients to find and access those fields.</value>
  </data>
  <data name="MiKo_3050_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/how-to-implement-a-dependency-property</value>
  </data>
  <data name="MiKo_3050_MessageFormat" xml:space="preserve">
    <value>Make it 'public static readonly'</value>
  </data>
  <data name="MiKo_3050_Title" xml:space="preserve">
    <value>DependencyProperty fields should be 'public static readonly'</value>
  </data>
  <data name="MiKo_3051_CodeFixTitle" xml:space="preserve">
    <value>Use 'nameof'</value>
  </data>
  <data name="MiKo_3051_Description" xml:space="preserve">
    <value>To avoid typos, fields that are the back of a DependencyProperty should be registered via 'DependencyProperty.Register()' and the 'nameof' operator.
In addition, the correct property names, property types and owing types should be provided.</value>
  </data>
  <data name="MiKo_3051_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/how-to-implement-a-dependency-property</value>
  </data>
  <data name="MiKo_3051_MessageFormat" xml:space="preserve">
    <value>Use '{1}' instead</value>
  </data>
  <data name="MiKo_3051_Title" xml:space="preserve">
    <value>DependencyProperty fields should be properly registered</value>
  </data>
  <data name="MiKo_3052_CodeFixTitle" xml:space="preserve">
    <value>Make DependencyPropertyKey 'private static readonly'</value>
  </data>
  <data name="MiKo_3052_Description" xml:space="preserve">
    <value>Fields that are the back of a DependencyPropertyKey should be made non-public, 'static readonly' to prevent clients to find and access those fields.</value>
  </data>
  <data name="MiKo_3052_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/api/system.windows.dependencypropertykey</value>
  </data>
  <data name="MiKo_3052_MessageFormat" xml:space="preserve">
    <value>Make it non-public 'static readonly'</value>
  </data>
  <data name="MiKo_3052_Title" xml:space="preserve">
    <value>DependencyPropertyKey fields should be non-public 'static readonly'</value>
  </data>
  <data name="MiKo_3053_Description" xml:space="preserve">
    <value>To avoid typos, fields that are the Key of a DependencyProperty should be registered via 'DependencyProperty.RegisterReadOnly()' and the 'nameof' operator.
In addition, the correct property names, property types and owing types should be provided.</value>
  </data>
  <data name="MiKo_3053_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/api/system.windows.dependencyproperty.registerreadonly</value>
  </data>
  <data name="MiKo_3053_MessageFormat" xml:space="preserve">
    <value>Use '{1}' instead</value>
  </data>
  <data name="MiKo_3053_Title" xml:space="preserve">
    <value>DependencyPropertyKey fields should be properly registered</value>
  </data>
  <data name="MiKo_3054_CodeFixTitle" xml:space="preserve">
    <value>Expose DependencyProperty identifier</value>
  </data>
  <data name="MiKo_3054_Description" xml:space="preserve">
    <value>Read-only dependency properties are defined by 'DependencyPropertyKey' fields and should not be visible to the public.
To made them available, it is recommended to expose a dependency property identifier for such read-only dependency property.
That can be done by exposing the value of 'DependencyPropertyKey.DependencyProperty' as a 'public static readonly' field on the specific class.</value>
  </data>
  <data name="MiKo_3054_HelpLinkUri" xml:space="preserve">
    <value>https://docs.microsoft.com/en-us/dotnet/api/system.windows.dependencyproperty.registerreadonly</value>
  </data>
  <data name="MiKo_3054_MessageFormat" xml:space="preserve">
    <value>Expose a DependencyProperty identifier for the read-only dependency property '{0}'</value>
  </data>
  <data name="MiKo_3054_Title" xml:space="preserve">
    <value>A read-only DependencyProperty should have an exposed DependencyProperty identifier</value>
  </data>
  <data name="MiKo_3060_CodeFixTitle" xml:space="preserve">
    <value>Remove Assert call</value>
  </data>
  <data name="MiKo_3060_Description" xml:space="preserve">
    <value>If you use Debug.Assert() or Trace.Assert(), then you want to ensure something. Nevertheless, this has several drawbacks:
1. Debug.Assert() does not work in Release mode (whereas Trace.Assert() does).
2. You cannot do anything here except to confirm the situation.
3. There is no failure handling available.
4. Calling code is not informed about the code and cannot handle the situation properly.

So instead of using Debug.Assert() or Trace.Assert() throw an exception, such as an InvalidOperationException.

Especially never use Debug.Assert() or Trace.Assert() in (unit) test code. That's why the test code is there. Let the test fail in a case were Debug.Assert() or Trace.Assert() would apply.</value>
  </data>
  <data name="MiKo_3060_MessageFormat" xml:space="preserve">
    <value>Do not use '{1}'</value>
  </data>
  <data name="MiKo_3060_Title" xml:space="preserve">
    <value>Debug.Assert or Trace.Assert shall not be used</value>
  </data>
  <data name="MiKo_3061_Description" xml:space="preserve">
    <value>Often, loggers are requested via a type. Unfortunately, that most likely results in the situation that the logs contain no useful categories. Even worse, developers try to control the log output via the different severities (Debug, Info, ...).
As a result, the logs contain a lot of garbage. So, while analyzing log files it is unclear which log statement belongs into which category.

Therefore, the logger should be requested via a string that acts as category.</value>
  </data>
  <data name="MiKo_3061_MessageFormat" xml:space="preserve">
    <value>Use a string as category instead</value>
  </data>
  <data name="MiKo_3061_Title" xml:space="preserve">
    <value>Loggers shall use a proper log category</value>
  </data>
  <data name="MiKo_3062_CodeFixTitle" xml:space="preserve">
    <value>End log message with colon</value>
  </data>
  <data name="MiKo_3062_Description" xml:space="preserve">
    <value>Log messages that log exceptions should end with a colon, to indicate that there is an exception.</value>
  </data>
  <data name="MiKo_3062_MessageFormat" xml:space="preserve">
    <value>End log message with colon</value>
  </data>
  <data name="MiKo_3062_Title" xml:space="preserve">
    <value>Do end log messages for exceptions with a colon</value>
  </data>
  <data name="MiKo_3063_CodeFixTitle" xml:space="preserve">
    <value>End log message with dot</value>
  </data>
  <data name="MiKo_3063_Description" xml:space="preserve">
    <value>Log messages that do not log exceptions should end with a dot because there is no exception to focus on.</value>
  </data>
  <data name="MiKo_3063_MessageFormat" xml:space="preserve">
    <value>End log message with dot</value>
  </data>
  <data name="MiKo_3063_Title" xml:space="preserve">
    <value>Do end non-exceptional log messages with a dot</value>
  </data>
  <data name="MiKo_3070_Description" xml:space="preserve">
    <value>Methods that return IEnumerable are expected to be used in foreach loops or Linq queries.
It is unexpected that such places throw a NullReferenceException or ArgumentNullException, so these methods should never return null.</value>
  </data>
  <data name="MiKo_3070_MessageFormat" xml:space="preserve">
    <value>Do not return null</value>
  </data>
  <data name="MiKo_3070_Title" xml:space="preserve">
    <value>Methods that return IEnumerable shall never return null</value>
  </data>
  <data name="MiKo_3071_Description" xml:space="preserve">
    <value>Methods that return Task are expected to be used for async calls.
It is unexpected that when calling such methods you get a NullReferenceException thrown, so these methods should never return null.</value>
  </data>
  <data name="MiKo_3071_MessageFormat" xml:space="preserve">
    <value>Do not return null</value>
  </data>
  <data name="MiKo_3071_Title" xml:space="preserve">
    <value>Methods that return Task shall never return null</value>
  </data>
  <data name="MiKo_3072_Description" xml:space="preserve">
    <value>Methods that are visible to the public should not return a List&lt;&gt; or Dictionary&lt;&gt;. Instead, they should return the interfaces IList&lt;&gt; or IDictionary&lt;&gt;.
Doing so allows to change the implementation of the return value whenever it's needed. Otherwise, the method is bound to always and forever return a List&lt;&gt; or Dictionary&lt;&gt;.</value>
  </data>
  <data name="MiKo_3072_MessageFormat" xml:space="preserve">
    <value>Do not return {1}&lt;&gt;</value>
  </data>
  <data name="MiKo_3072_Title" xml:space="preserve">
    <value>Non-private methods should not return 'List&lt;&gt;' or 'Dictionary&lt;&gt;'</value>
  </data>
  <data name="MiKo_3073_Description" xml:space="preserve">
    <value>Constructors should run completely. They should not partially initialize the objects.</value>
  </data>
  <data name="MiKo_3073_MessageFormat" xml:space="preserve">
    <value>Do not return inside constructor</value>
  </data>
  <data name="MiKo_3073_Title" xml:space="preserve">
    <value>Do not leave objects partially initialized</value>
  </data>
  <data name="MiKo_3074_Description" xml:space="preserve">
    <value>The idea of a constructor is to create an initialized instance of that specific type. Its responsibility is not to create instances of other types.
So, having 'ref' or 'out' parameters on a constructor contradicts the complete concept of the constructor as these parameters solely exist to provide instances of (other types) out of that constructor in addition to the instance that is created and initialized by the constructor.</value>
  </data>
  <data name="MiKo_3074_MessageFormat" xml:space="preserve">
    <value>Do not use '{1}'</value>
  </data>
  <data name="MiKo_3074_Title" xml:space="preserve">
    <value>Do not define 'ref' or 'out' parameters on constructors</value>
  </data>
  <data name="MiKo_3075_CodeFixTitle" xml:space="preserve">
    <value>Seal class or make it static</value>
  </data>
  <data name="MiKo_3075_Description" xml:space="preserve">
    <value>To ease maintenance, internal and private types should be either static or sealed unless derivation from them is required.

As with any implementation detail, they can be easily changed if/when derivation is required in the future.</value>
  </data>
  <data name="MiKo_3075_MessageFormat" xml:space="preserve">
    <value>Seal class or make it static</value>
  </data>
  <data name="MiKo_3075_Title" xml:space="preserve">
    <value>Internal and private types should be either static or sealed unless derivation from them is required</value>
  </data>
  <data name="MiKo_3076_Description" xml:space="preserve">
    <value>If a static member initializer uses another member that is defined below or in another type part, then the chance is high that during runtime the static member gets initialized with the wrong value. That's because the member gets initialized before the other referenced member gets initialized.

This leads to subtle bugs, such as TypeInitializerExceptions or incorrect values.</value>
  </data>
  <data name="MiKo_3076_MessageFormat" xml:space="preserve">
    <value>Static member initializer refers to static member(s) {1} below or in other type part</value>
  </data>
  <data name="MiKo_3076_Title" xml:space="preserve">
    <value>Do not initialize static member with static member below or in other type part</value>
  </data>
  <data name="MiKo_3077_CodeFixTitle" xml:space="preserve">
    <value>Apply a default value</value>
  </data>
  <data name="MiKo_3077_Description" xml:space="preserve">
    <value>Explicitly setting values for properties that return an 'Enum' allows to easily spot the (default) value and detect any change.
So it assists in thinking about whether the value is the intended one.</value>
  </data>
  <data name="MiKo_3077_MessageFormat" xml:space="preserve">
    <value>Set a default value</value>
  </data>
  <data name="MiKo_3077_Title" xml:space="preserve">
    <value>Properties that return an Enum should have a default value</value>
  </data>
  <data name="MiKo_3081_CodeFixTitle" xml:space="preserve">
    <value>Apply 'is false' pattern</value>
  </data>
  <data name="MiKo_3081_Description" xml:space="preserve">
    <value>Logical NOT conditions are hard to recognize if they are coded using the '!' character. Code that uses 'is false' is much easier to read and understand.</value>
  </data>
  <data name="MiKo_3081_MessageFormat" xml:space="preserve">
    <value>Use pattern 'is false' instead of ' ! '</value>
  </data>
  <data name="MiKo_3081_Title" xml:space="preserve">
    <value>Pattern matching is preferred over a logical NOT condition</value>
  </data>
  <data name="MiKo_3082_CodeFixTitle" xml:space="preserve">
    <value>Apply 'is' pattern</value>
  </data>
  <data name="MiKo_3082_Description" xml:space="preserve">
    <value>Logical comparisons using the 'is' pattern matching are more natural and therefore easier to read and understand than using the '==' operator.</value>
  </data>
  <data name="MiKo_3082_MessageFormat" xml:space="preserve">
    <value>Use 'is' instead of '=='</value>
  </data>
  <data name="MiKo_3082_Title" xml:space="preserve">
    <value>Pattern matching is preferred over a logical comparison with 'true' or 'false'</value>
  </data>
  <data name="MiKo_3083_CodeFixTitle" xml:space="preserve">
    <value>Apply 'is null' pattern</value>
  </data>
  <data name="MiKo_3083_Description" xml:space="preserve">
    <value>Null checks using the 'is' pattern matching is more natural and therefore easier to read and understand than using the '==' operator.</value>
  </data>
  <data name="MiKo_3083_MessageFormat" xml:space="preserve">
    <value>Use 'is' instead of '=='</value>
  </data>
  <data name="MiKo_3083_Title" xml:space="preserve">
    <value>Pattern matching is preferred for null checks</value>
  </data>
  <data name="MiKo_3084_CodeFixTitle" xml:space="preserve">
    <value>Place constant value on right side</value>
  </data>
  <data name="MiKo_3084_Description" xml:space="preserve">
    <value>To increase readability, do not place constants on the left side of an operator. Instead, place it on the right side. This makes the code look more natural.</value>
  </data>
  <data name="MiKo_3084_MessageFormat" xml:space="preserve">
    <value>Place it on right side of '{1}'</value>
  </data>
  <data name="MiKo_3084_Title" xml:space="preserve">
    <value>Do not place constants on the left side for comparisons</value>
  </data>
  <data name="MiKo_3085_Description" xml:space="preserve">
    <value>Conditional statements which span a lot of characters are hard to read. That makes them harder to maintain.
They should be either short (to see at a glance what's going on) or refactored into if-else statements.</value>
  </data>
  <data name="MiKo_3085_MessageFormat" xml:space="preserve">
    <value>Shorten conditional or use 'if ... else ...' instead</value>
  </data>
  <data name="MiKo_3085_Title" xml:space="preserve">
    <value>Conditional statements should be short</value>
  </data>
  <data name="MiKo_3086_Description" xml:space="preserve">
    <value>Nested conditional (or coalesce) statements are hard to read and understand. Therefore such statements should not be nested. Instead, if-else statements should be used.</value>
  </data>
  <data name="MiKo_3086_MessageFormat" xml:space="preserve">
    <value>Do not nest conditional</value>
  </data>
  <data name="MiKo_3086_Title" xml:space="preserve">
    <value>Do not nest conditional statements</value>
  </data>
  <data name="MiKo_3090_Description" xml:space="preserve">
    <value>Exceptions should be thrown inside of try or catch blocks (or normal code blocks), but not inside of finally blocks.
Those finally blocks are intended for cleaning stuff up; or to ensure that some code runs in all (except a few) situations.</value>
  </data>
  <data name="MiKo_3090_MessageFormat" xml:space="preserve">
    <value>Do not throw from finally block</value>
  </data>
  <data name="MiKo_3090_Title" xml:space="preserve">
    <value>Do not throw exceptions in finally blocks</value>
  </data>
  <data name="MiKo_3091_Description" xml:space="preserve">
    <value>Events should be raised inside of try or catch blocks (or normal code blocks), but not inside of finally blocks.
Those finally blocks are intended for cleaning stuff up.</value>
  </data>
  <data name="MiKo_3091_MessageFormat" xml:space="preserve">
    <value>Do not raise '{1}' from finally block</value>
  </data>
  <data name="MiKo_3091_Title" xml:space="preserve">
    <value>Do not raise events in finally blocks</value>
  </data>
  <data name="MiKo_3092_Description" xml:space="preserve">
    <value>To avoid deadlocks, events should never be raised inside of lock statements. Instead, the event handlers should be collected and the event should be raised outside the lock.</value>
  </data>
  <data name="MiKo_3092_MessageFormat" xml:space="preserve">
    <value>Do not raise event inside lock</value>
  </data>
  <data name="MiKo_3092_Title" xml:space="preserve">
    <value>Do not raise events in locks</value>
  </data>
  <data name="MiKo_3093_Description" xml:space="preserve">
    <value>To avoid deadlocks, delegates should never be invoked inside of lock statements. Instead, the information needed should be collected inside the lock and the delegate should be invoked outside the lock.</value>
  </data>
  <data name="MiKo_3093_MessageFormat" xml:space="preserve">
    <value>Do not invoke delegate inside lock</value>
  </data>
  <data name="MiKo_3093_Title" xml:space="preserve">
    <value>Do not invoke delegates inside locks</value>
  </data>
  <data name="MiKo_3100_Description" xml:space="preserve">
    <value>To ease maintenance, test classes should be in the exact same namespace as the type they test.
This allows easy usage without any arbitrary using directives. It also mimics the project structure and allows to discover the tests much easier.</value>
  </data>
  <data name="MiKo_3100_MessageFormat" xml:space="preserve">
    <value>Place test class in namespace '{1}'</value>
  </data>
  <data name="MiKo_3100_Title" xml:space="preserve">
    <value>Test classes and types under test belong in same namespace</value>
  </data>
  <data name="MiKo_3101_Description" xml:space="preserve">
    <value>A class that is marked as a unit test class should contain unit tests.</value>
  </data>
  <data name="MiKo_3101_MessageFormat" xml:space="preserve">
    <value>Test class should contain tests</value>
  </data>
  <data name="MiKo_3101_Title" xml:space="preserve">
    <value>Test classes should contain tests</value>
  </data>
  <data name="MiKo_3102_Description" xml:space="preserve">
    <value>Tests should test a very specific scenario. Therefore there is no need to have a condition, because in that situation a test tests more than one scenario.
So having a condition inside a test is a huge code smell.</value>
  </data>
  <data name="MiKo_3102_MessageFormat" xml:space="preserve">
    <value>Refactor test to remove condition</value>
  </data>
  <data name="MiKo_3102_Title" xml:space="preserve">
    <value>Test methods should not contain conditional statements (such as 'if', 'switch', etc.)</value>
  </data>
  <data name="MiKo_3103_CodeFixTitle" xml:space="preserve">
    <value>Use hard-coded GUID</value>
  </data>
  <data name="MiKo_3103_Description" xml:space="preserve">
    <value>Tests should be specific to make them reproducible and easy to maintain. A GUID that is generated is not reproducible at all and cannot be easily found in case a test fails.
Therefore, a hard-coded GUID should be used instead.</value>
  </data>
  <data name="MiKo_3103_MessageFormat" xml:space="preserve">
    <value>Use a hard-coded GUID instead</value>
  </data>
  <data name="MiKo_3103_Title" xml:space="preserve">
    <value>Test methods should not use 'Guid.NewGuid()'</value>
  </data>
  <data name="MiKo_3104_CodeFixTitle" xml:space="preserve">
    <value>Remove [Combinatorial] attribute</value>
  </data>
  <data name="MiKo_3104_Description" xml:space="preserve">
    <value>NUnit's [Combinatorial] attribute shall be used only if there is a test method that has at least 2 parameters to create the combinatorial. Otherwise there is no reason to mark a test with that attribute.</value>
  </data>
  <data name="MiKo_3104_MessageFormat" xml:space="preserve">
    <value>Wrong usage of [Combinatorial]</value>
  </data>
  <data name="MiKo_3104_Title" xml:space="preserve">
    <value>Use NUnit's [Combinatorial] attribute properly</value>
  </data>
  <data name="MiKo_3105_CodeFixTitle" xml:space="preserve">
    <value>Use 'Assert.That'</value>
  </data>
  <data name="MiKo_3105_Description" xml:space="preserve">
    <value>NUnit's fluent Assert approach is easier to understand. Following that approach, developers will most times not make the common mistake to mix up the 'actual' and 'expected' values.</value>
  </data>
  <data name="MiKo_3105_HelpLinkUri" xml:space="preserve">
    <value>https://github.com/nunit/docs/wiki/Constraint-Model</value>
  </data>
  <data name="MiKo_3105_MessageFormat" xml:space="preserve">
    <value>Use 'Assert.That' instead</value>
  </data>
  <data name="MiKo_3105_Title" xml:space="preserve">
    <value>Test methods should use NUnit's fluent Assert approach</value>
  </data>
  <data name="MiKo_3106_Description" xml:space="preserve">
    <value>Assertions such as Assert.That(...) that contain operators such as ==, !=, &lt;=, &lt;, &gt;=, &gt; assert for booleans.
The same is valid for patterns such as 'is true' or type checks via 'is' or the Equals() method.

If such a test fails it is difficult to understand why it failed. The failure reason gives no useful hint (e.g. 'true' expected but 'false' received), so the failure needs to be carefully inspected.
At worst the test needs to be debugged to find out what went wrong. That is annoying and becomes even more annoying if the test itself is a shaky one.

In contrast, the failure would be much easier to understand if the test would immediately state what was expected (e.g. '5' was expected but '12' was received).</value>
  </data>
  <data name="MiKo_3106_MessageFormat" xml:space="preserve">
    <value>Do not use '{1}' in assertion</value>
  </data>
  <data name="MiKo_3106_Title" xml:space="preserve">
    <value>Assertions should not use equality or comparison operators</value>
  </data>
  <data name="MiKo_3107_CodeFixTitle" xml:space="preserve">
    <value>Change Moq call to default value</value>
  </data>
  <data name="MiKo_3107_Description" xml:space="preserve">
    <value>It is troublesome to have code that attemps to use Moq mocks but actually does not use them properly. So condition matchers should be used on mocks to setup or verify conditions. Such matchers should not be used on constructors or methods of non-mocks as they don't make sense there.</value>
  </data>
  <data name="MiKo_3107_MessageFormat" xml:space="preserve">
    <value>Use a mock instead</value>
  </data>
  <data name="MiKo_3107_Title" xml:space="preserve">
    <value>Moq Mock condition matchers should be used on mocks only</value>
  </data>
  <data name="MiKo_3108_Description" xml:space="preserve">
    <value>Tests should use assertions to check the behavior of the code for correctness. A missing assertion indicates a test that does not check anything and is therefore not meaningful.</value>
  </data>
  <data name="MiKo_3108_MessageFormat" xml:space="preserve">
    <value>Add assertion to test</value>
  </data>
  <data name="MiKo_3108_Title" xml:space="preserve">
    <value>Test methods should use assertions</value>
  </data>
  <data name="MiKo_3109_CodeFixTitle" xml:space="preserve">
    <value>Add default assertion message</value>
  </data>
  <data name="MiKo_3109_Description" xml:space="preserve">
    <value>Assertions should contain messages that tell the reason(s) why something was expected but failed. This makes it easier to understand why a test failed in particular.</value>
  </data>
  <data name="MiKo_3109_MessageFormat" xml:space="preserve">
    <value>Provide an assertion message</value>
  </data>
  <data name="MiKo_3109_Title" xml:space="preserve">
    <value>Multiple assertions shall use assertion messages</value>
  </data>
  <data name="MiKo_3110_CodeFixTitle" xml:space="preserve">
    <value>Use 'Assert.That(..., Has...)'</value>
  </data>
  <data name="MiKo_3110_Description" xml:space="preserve">
    <value>Assertions such as Assert.That(...) using 'Count' or 'Length' assert for exact values.
If such a test fails it is difficult to find out why it exactly failed as the failure reason gives no useful hint (e.g. '5' expected but '3' received).

So the failure needs to be carefully inspected. At worst the test needs to be debugged to find out what went wrong.
That is annoying and becomes even more annoying if the test itself is a shaky one.

In contrast, the failure would be much easier to understand if the test would immediately state what was expected (e.g. Expected items 'A', 'B' and 'C' but found 'B' and 'D').</value>
  </data>
  <data name="MiKo_3110_MessageFormat" xml:space="preserve">
    <value>Do not use '{1}' in assertion</value>
  </data>
  <data name="MiKo_3110_Title" xml:space="preserve">
    <value>Assertions should not use 'Count' or 'Length'</value>
  </data>
  <data name="MiKo_3111_CodeFixTitle" xml:space="preserve">
    <value>Use 'Zero'</value>
  </data>
  <data name="MiKo_3111_Description" xml:space="preserve">
    <value>For clarity, tests that assert for zero should use 'Is.Zero' instead of 'Is.EqualTo(0)'.</value>
  </data>
  <data name="MiKo_3111_MessageFormat" xml:space="preserve">
    <value>Use 'Zero' instead</value>
  </data>
  <data name="MiKo_3111_Title" xml:space="preserve">
    <value>Assertions should use 'Is.Zero' instead of 'Is.EqualTo(0)'</value>
  </data>
  <data name="MiKo_3112_CodeFixTitle" xml:space="preserve">
    <value>Use 'Is.Empty'</value>
  </data>
  <data name="MiKo_3112_Description" xml:space="preserve">
    <value>For clarity, tests that assert on collections for emptiness should use 'Is.Empty' instead of 'Has.Count.Zero'.</value>
  </data>
  <data name="MiKo_3112_MessageFormat" xml:space="preserve">
    <value>Use 'Is.Empty' instead</value>
  </data>
  <data name="MiKo_3112_Title" xml:space="preserve">
    <value>Assertions should use 'Is.Empty' instead of 'Has.Count.Zero'</value>
  </data>
  <data name="MiKo_3201_CodeFixTitle" xml:space="preserve">
    <value>Surround with blank lines</value>
  </data>
  <data name="MiKo_3201_Description" xml:space="preserve">
    <value>To separate Logging visually from the business code, they should be surrounded by blank lines. That makes them easier to spot and ignore.</value>
  </data>
  <data name="MiKo_3201_MessageFormat" xml:space="preserve">
    <value>Surround log statement(s) with blank lines</value>
  </data>
  <data name="MiKo_3201_Title" xml:space="preserve">
    <value>Log statements should be preceded and followed by blank lines</value>
  </data>
  <data name="MiKo_3202_CodeFixTitle" xml:space="preserve">
    <value>Surround with blank lines</value>
  </data>
  <data name="MiKo_3202_Description" xml:space="preserve">
    <value>To separate Assertions visually from the test code, they should be surrounded by blank lines. That makes them easier to spot and ignore.</value>
  </data>
  <data name="MiKo_3202_MessageFormat" xml:space="preserve">
    <value>Surround assertion statement(s) with blank lines</value>
  </data>
  <data name="MiKo_3202_Title" xml:space="preserve">
    <value>Assertion statements should be preceded and followed by blank lines</value>
  </data>
  <data name="MiKo_3203_CodeFixTitle" xml:space="preserve">
    <value>Precede with blank line</value>
  </data>
  <data name="MiKo_3203_Description" xml:space="preserve">
    <value>To separate local variables visually from executing code, they should be preceded by blank lines. That makes them easier to spot.</value>
  </data>
  <data name="MiKo_3203_MessageFormat" xml:space="preserve">
    <value>Precede local variable with a blank line</value>
  </data>
  <data name="MiKo_3203_Title" xml:space="preserve">
    <value>Local variable statements should be preceded by blank lines</value>
  </data>
  <data name="MiKo_3204_CodeFixTitle" xml:space="preserve">
    <value>Precede with blank line</value>
  </data>
  <data name="MiKo_3204_Description" xml:space="preserve">
    <value>To separate variable assignments visually from executing code, they should be preceded by blank lines. That makes them easier to spot.</value>
  </data>
  <data name="MiKo_3204_MessageFormat" xml:space="preserve">
    <value>Precede variable assignment with a blank line</value>
  </data>
  <data name="MiKo_3204_Title" xml:space="preserve">
    <value>Variable assignment statements should be preceded by blank lines</value>
  </data>
  <data name="MiKo_3205_CodeFixTitle" xml:space="preserve">
    <value>Precede with blank line</value>
  </data>
  <data name="MiKo_3205_Description" xml:space="preserve">
    <value>To separate method returns visually from executing code, they should be preceded by blank lines. That makes them easier to spot.</value>
  </data>
  <data name="MiKo_3205_MessageFormat" xml:space="preserve">
    <value>Precede return statement with a blank line</value>
  </data>
  <data name="MiKo_3205_Title" xml:space="preserve">
    <value>Return statements should be preceded by blank lines</value>
  </data>
  <data name="MiKo_3206_CodeFixTitle" xml:space="preserve">
    <value>Surround with blank lines</value>
  </data>
  <data name="MiKo_3206_Description" xml:space="preserve">
    <value>To separate awaited statements visually from other code, they should be surrounded by blank lines. That makes them easier to spot.</value>
  </data>
  <data name="MiKo_3206_MessageFormat" xml:space="preserve">
    <value>Surround awaited statement with a blank line</value>
  </data>
  <data name="MiKo_3206_Title" xml:space="preserve">
    <value>Awaited statements should be surrounded by blank lines</value>
  </data>
  <data name="MiKo_3207_CodeFixTitle" xml:space="preserve">
    <value>Surround with blank lines</value>
  </data>
  <data name="MiKo_3207_Description" xml:space="preserve">
    <value>To separate test statements visually from other code, they should be surrounded by blank lines. That makes them easier to spot.</value>
  </data>
  <data name="MiKo_3207_MessageFormat" xml:space="preserve">
    <value>Surround test statement with a blank line</value>
  </data>
  <data name="MiKo_3207_Title" xml:space="preserve">
    <value>Test statements should be surrounded by blank lines</value>
  </data>
  <data name="MiKo_3210_CodeFixTitle" xml:space="preserve">
    <value>Use lambda expression body</value>
  </data>
  <data name="MiKo_3210_Description" xml:space="preserve">
    <value>Using parenthesized lambda expressions with blocks that contain a single statement leads to some noise caused by the braces. Lambda expressions with expression bodies avoid that noise. So they should be used instead.</value>
  </data>
  <data name="MiKo_3210_MessageFormat" xml:space="preserve">
    <value>Use lambda expression body instead</value>
  </data>
  <data name="MiKo_3210_Title" xml:space="preserve">
    <value>Favor lambda expression bodies instead of parenthesized lambda expression blocks for single statements</value>
  </data>
  <data name="MiKo_3401_Description" xml:space="preserve">
    <value>Namespaces should have only a limited depth. If a namespace hierarchy becomes too deep, then the namespaces are probably too concrete or special to make sense.
Such namespaces should be flattened.</value>
  </data>
  <data name="MiKo_3401_MessageFormat" xml:space="preserve">
    <value>Namespace hierarchy too deep: {1,4} (max. {2})</value>
  </data>
  <data name="MiKo_3401_Title" xml:space="preserve">
    <value>Namespace hierarchies should not be too deep</value>
  </data>
  <data name="MiKo_4001_CodeFixTitle" xml:space="preserve">
    <value>Place and order method side-by-side with overloads</value>
  </data>
  <data name="MiKo_4001_Description" xml:space="preserve">
    <value>Methods that have the same name but a different number of parameters should be ordered in a way so that each method with fewer parameters is ordered before a method with more parameters.</value>
  </data>
  <data name="MiKo_4001_MessageFormat" xml:space="preserve">
    <value>Order methods in following way:
{1}
</value>
  </data>
  <data name="MiKo_4001_Title" xml:space="preserve">
    <value>Methods with same name should be ordered based on the number of their parameters</value>
  </data>
  <data name="MiKo_4002_CodeFixTitle" xml:space="preserve">
    <value>Place method side-by-side with overloads</value>
  </data>
  <data name="MiKo_4002_Description" xml:space="preserve">
    <value>Methods that have the same name should be placed side-by-side so that those methods can be easily found together.</value>
  </data>
  <data name="MiKo_4002_MessageFormat" xml:space="preserve">
    <value>Place method '{0}' side-by-side with following other methods:
{1}
</value>
  </data>
  <data name="MiKo_4002_Title" xml:space="preserve">
    <value>Methods with same name and accessibility should be placed side-by-side</value>
  </data>
  <data name="MiKo_4003_CodeFixTitle" xml:space="preserve">
    <value>Place Dispose method after constructors and finalizers</value>
  </data>
  <data name="MiKo_4003_Description" xml:space="preserve">
    <value>Ctors, finalizers and Dispose methods are all directly related to the lifetime of an object. Therefore, they belong together and should be placed side by side.</value>
  </data>
  <data name="MiKo_4003_MessageFormat" xml:space="preserve">
    <value>Place '{0}' directly after all ctors and finalizers</value>
  </data>
  <data name="MiKo_4003_Title" xml:space="preserve">
    <value>Dispose methods should be placed directly after constructors and finalizers</value>
  </data>
  <data name="MiKo_4004_CodeFixTitle" xml:space="preserve">
    <value>Place 'Dispose' method first</value>
  </data>
  <data name="MiKo_4004_Description" xml:space="preserve">
    <value>Dispose methods are all directly related to the lifetime of an object. Therefore, they should be placed before all other methods of the same accessibility.</value>
  </data>
  <data name="MiKo_4004_MessageFormat" xml:space="preserve">
    <value>Place 'Dispose' method first</value>
  </data>
  <data name="MiKo_4004_Title" xml:space="preserve">
    <value>Dispose methods should be placed before all other methods of the same accessibility</value>
  </data>
  <data name="MiKo_4005_CodeFixTitle" xml:space="preserve">
    <value>Place interface directly after type declaration</value>
  </data>
  <data name="MiKo_4005_Description" xml:space="preserve">
    <value>To ease reading, the interface that gives the type its name should be listed as first interface. All the other implemented interfaces should be placed behind.</value>
  </data>
  <data name="MiKo_4005_MessageFormat" xml:space="preserve">
    <value>Place '{1}' as first interface directly after type declaration</value>
  </data>
  <data name="MiKo_4005_Title" xml:space="preserve">
    <value>The interface that gives a type its name should be placed directly after the type's declaration</value>
  </data>
  <data name="MiKo_4101_CodeFixTitle" xml:space="preserve">
    <value>Place method after one-time methods and before test cleanup and all other test methods</value>
  </data>
  <data name="MiKo_4101_Description" xml:space="preserve">
    <value>Test initialization method define the most common parts that tests shall contain. So to ease their finding they should be ordered directly after all one-time methods and before all other methods.</value>
  </data>
  <data name="MiKo_4101_MessageFormat" xml:space="preserve">
    <value>Place test initialization method after [OneTimeSetUp] / [OneTimeTearDown] methods and before test cleanup and all other test methods</value>
  </data>
  <data name="MiKo_4101_Title" xml:space="preserve">
    <value>Test initialization methods should be ordered directly after One-Time methods</value>
  </data>
  <data name="MiKo_4102_CodeFixTitle" xml:space="preserve">
    <value>Place method after test initialization methods and before all test methods</value>
  </data>
  <data name="MiKo_4102_Description" xml:space="preserve">
    <value>Test cleanup methods define the common parts that shall be executed after any test has been finished. So to ease their finding they should be ordered before the test methods.</value>
  </data>
  <data name="MiKo_4102_MessageFormat" xml:space="preserve">
    <value>Place test cleanup method after test initialization methods and before all test methods</value>
  </data>
  <data name="MiKo_4102_Title" xml:space="preserve">
    <value>Test cleanup methods should be ordered after test initialization methods and before test methods</value>
  </data>
  <data name="MiKo_4103_CodeFixTitle" xml:space="preserve">
    <value>Place method before all other methods</value>
  </data>
  <data name="MiKo_4103_Description" xml:space="preserve">
    <value>One-Time test initialization method define the most common parts that the test environment shall have. So to ease their finding they should be ordered first.</value>
  </data>
  <data name="MiKo_4103_MessageFormat" xml:space="preserve">
    <value>Place [OneTimeSetUp] method before all other methods</value>
  </data>
  <data name="MiKo_4103_Title" xml:space="preserve">
    <value>One-Time test initialization methods should be ordered before all other methods</value>
  </data>
  <data name="MiKo_4104_CodeFixTitle" xml:space="preserve">
    <value>Place method directly after [OneTimeSetUp] method and before all other methods</value>
  </data>
  <data name="MiKo_4104_Description" xml:space="preserve">
    <value>One-Time test cleanup methods define the common parts that shall be executed after all tests have been finished, to clean up the test environment. So to ease their finding they should be ordered directly after the One-Time test initialization methods.</value>
  </data>
  <data name="MiKo_4104_MessageFormat" xml:space="preserve">
    <value>Place [OneTimeTearDown] method directly after [OneTimeSetUp] method and before all other methods</value>
  </data>
  <data name="MiKo_4104_Title" xml:space="preserve">
    <value>One-Time test cleanup methods should be ordered directly after One-Time test initialization methods</value>
  </data>
  <data name="MiKo_5001_CodeFixTitle" xml:space="preserve">
    <value>Place inside 'if'</value>
  </data>
  <data name="MiKo_5001_Description" xml:space="preserve">
    <value>For performance reasons, 'IsDebugEnabled' should be invoked before the 'Debug' or 'DebugFormat' methods get invoked as those require messages to be created. That creation (and the garbage collection of them as well) is not needed if the 'Debug' log level is not set.</value>
  </data>
  <data name="MiKo_5001_MessageFormat" xml:space="preserve">
    <value>Invoke '{2}' before invoking '{1}'</value>
  </data>
  <data name="MiKo_5001_Title" xml:space="preserve">
    <value>'Debug' and 'DebugFormat' methods should be invoked only after 'IsDebugEnabled'</value>
  </data>
  <data name="MiKo_5002_CodeFixTitle" xml:space="preserve">
    <value>Replace with non-'Format' method</value>
  </data>
  <data name="MiKo_5002_Description" xml:space="preserve">
    <value>For performance reasons, 'xxxFormat' methods (such as 'DebugFormat') should be invoked only with arguments to format the string. Otherwise, the corresponding non-formatting methods (such as 'Debug') should be invoked.</value>
  </data>
  <data name="MiKo_5002_MessageFormat" xml:space="preserve">
    <value>Invoke '{2}' instead</value>
  </data>
  <data name="MiKo_5002_Title" xml:space="preserve">
    <value>'xxxFormat' methods should be invoked with multiple arguments only</value>
  </data>
  <data name="MiKo_5003_Description" xml:space="preserve">
    <value>Log methods (such as 'Debug', 'Info', 'Warn', ...) provide an overload that takes an Exception. In case an Exception shall be logged, those Log methods should be invoked instead of those without Exception parameter.
That allows the Log framework to log not only the name of the exception but also additional information (such as it's stack trace).</value>
  </data>
  <data name="MiKo_5003_MessageFormat" xml:space="preserve">
    <value>Invoke '{1}' overload with exception parameter</value>
  </data>
  <data name="MiKo_5003_Title" xml:space="preserve">
    <value>Correct Log methods should be invoked for exceptions</value>
  </data>
  <data name="MiKo_5010_CodeFixTitle" xml:space="preserve">
    <value>Replace 'Equals' by '=='</value>
  </data>
  <data name="MiKo_5010_Description" xml:space="preserve">
    <value>For performance reasons, it makes no sense to use 'object.Equals()' on value types. Value types get boxed and unboxed when being casted to objects. That puts unnecessary pressure on the garbage collector as temporary objects are created and immediately get garbage collected.

Instead the equality operator should be used to compare value types.</value>
  </data>
  <data name="MiKo_5010_MessageFormat" xml:space="preserve">
    <value>Use '==' operator instead of 'object.Equals'</value>
  </data>
  <data name="MiKo_5010_Title" xml:space="preserve">
    <value>Do not use 'object.Equals()' on value types</value>
  </data>
  <data name="MiKo_5011_Description" xml:space="preserve">
    <value>For performance reasons (and to avoid large pressure on the garbage collector) strings should be concatenated with 'string.Concat()', 'string.Join()' or by using a 'StringBuilder'.</value>
  </data>
  <data name="MiKo_5011_MessageFormat" xml:space="preserve">
    <value>Use 'string.Concat()' or 'string.Join()' instead</value>
  </data>
  <data name="MiKo_5011_Title" xml:space="preserve">
    <value>Do not concatenate strings with += operator</value>
  </data>
  <data name="MiKo_5012_Description" xml:space="preserve">
    <value>From performance point of view it is a bad idea to let methods that use yield invoke themselves recursively. The underlying iterators are called much more times than intended, thus leading to an unexpectedly bad performance.</value>
  </data>
  <data name="MiKo_5012_HelpLinkUri" xml:space="preserve">
    <value>https://stackoverflow.com/questions/3969963/when-not-to-use-yield-return</value>
  </data>
  <data name="MiKo_5012_MessageFormat" xml:space="preserve">
    <value>Do not use yield recursively</value>
  </data>
  <data name="MiKo_5012_Title" xml:space="preserve">
    <value>Do not use 'yield return' for recursively defined structures</value>
  </data>
  <data name="MiKo_5013_CodeFixTitle" xml:space="preserve">
    <value>Use Array.Empty&lt;&gt;()</value>
  </data>
  <data name="MiKo_5013_Description" xml:space="preserve">
    <value>To avoid unnecessary memory consumption and pressure on the garbage collector, empty arrays should not be created manually. Instead, the method 'Array.Empty&lt;T&gt;()' should be used.</value>
  </data>
  <data name="MiKo_5013_MessageFormat" xml:space="preserve">
    <value>Do not create empty array</value>
  </data>
  <data name="MiKo_5013_Title" xml:space="preserve">
    <value>Do not create empty arrays</value>
  </data>
</root>